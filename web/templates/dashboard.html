{% extends "base.html" %}

{% block title %}Satori - Dashboard{% endblock %}

{% block content %}
<!-- Navigation -->
<nav class="navbar navbar-expand-lg px-4">
    <span class="navbar-brand">
        Satori
        <small class="text-muted ms-2" style="font-size: 0.65rem; font-weight: 400; opacity: 0.6;">{{ version }}</small>
    </span>
    <div class="ms-auto d-flex align-items-center">
        <!-- Wallet Dropdown -->
        <div class="dropdown me-3">
            <button class="btn btn-outline-light btn-sm dropdown-toggle" type="button" id="walletDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="material-icons align-middle" style="font-size: 16px;">account_balance_wallet</i>
                Wallet
            </button>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="walletDropdown" style="background: var(--bg-card); border: 1px solid var(--border-color);">
                <li>
                    <a class="dropdown-item" href="#" onclick="openImportWalletModal(); return false;" style="color: var(--text-primary);">
                        <i class="material-icons align-middle me-2" style="font-size: 18px;">upload_file</i>
                        Import Wallet
                    </a>
                </li>
            </ul>
        </div>

        <span class="me-3">
            <span class="status-indicator status-online" id="statusIndicator"></span>
            <span id="statusText">Connected</span>
        </span>
        <a href="{{ url_for('stake_management') }}" class="btn btn-outline-light btn-sm me-2">
            <i class="material-icons align-middle" style="font-size: 16px;">handshake</i>
            Stake Management
        </a>
        <a href="{{ url_for('logout') }}" class="btn btn-outline-light btn-sm me-2">Logout</a>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark/light mode">
            <i class="material-icons" id="themeIcon">light_mode</i>
        </button>
    </div>
</nav>

<!-- Import Wallet Modal -->
<div class="modal fade" id="importWalletModal" tabindex="-1" aria-labelledby="importWalletModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content" style="background: var(--bg-card); border: 1px solid var(--border-color);">
            <div class="modal-header" style="border-bottom: 1px solid var(--border-color);">
                <h5 class="modal-title" id="importWalletModalLabel">
                    <i class="material-icons align-middle me-2">upload_file</i>
                    Import Wallet
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="filter: invert(1);"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning">
                    <strong>Warning:</strong> Importing a wallet will replace your current wallet and restart the container.
                    Make sure you have backed up your current wallet first!
                </div>

                <div class="mb-3">
                    <label class="form-label">Select Wallet Folder</label>
                    <input type="file"
                           class="form-control"
                           id="walletFolderInputModal"
                           webkitdirectory
                           directory
                           multiple
                           accept=".yaml,.yml">
                    <small class="form-text text-muted">
                        Select the "wallet" folder containing wallet.yaml and vault.yaml
                    </small>
                </div>

                <div id="importFileListModal" class="mb-3" style="display: none;">
                    <label class="form-label">Files to Import:</label>
                    <ul id="importFileListItemsModal" class="small"></ul>
                </div>

                <div id="importResultModal" class="mt-3" style="display: none;"></div>
            </div>
            <div class="modal-footer" style="border-top: 1px solid var(--border-color);">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="importWalletFromModal()" id="importWalletBtnModal" disabled>
                    <i class="material-icons align-middle me-1">upload</i>
                    Import Wallet & Restart
                </button>
            </div>
        </div>
    </div>
</div>

<div class="container-fluid py-4">
    <div class="row g-4">
        <!-- Wallet Section -->
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">account_balance_wallet</i>
                        Wallet
                    </h5>
                    <a href="#" class="btn btn-outline-secondary btn-sm" onclick="toggleIdentityWallet(); return false;">
                        <i class="material-icons align-middle" style="font-size: 16px;">badge</i>
                        Identity
                    </a>
                </div>
                <div class="card-body">
                    <div class="row">
                        <!-- Left side: QR Code and Address -->
                        <div class="col-lg-6 mb-4 mb-lg-0">
                            <div class="text-center mb-3">
                                <div id="walletQrCode" class="mb-3" style="display: inline-block; background: white; padding: 10px; border-radius: 10px;">
                                    <p class="text-muted mb-0">Loading QR code...</p>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Wallet Address</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="walletAddress" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('walletAddress')" title="Copy to clipboard">
                                        <i class="material-icons align-middle">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="text-center">
                                <p id="showPrivateKeyBtn" class="text-danger mb-2" style="cursor: pointer;" onclick="togglePrivateKey()">
                                    <i class="material-icons align-middle" style="font-size: 18px;">visibility</i>
                                    Show Private Key
                                </p>
                                <div id="privateKeySection" style="display: none;">
                                    <p class="text-muted mb-2" style="cursor: pointer;" onclick="togglePrivateKey()">
                                        <i class="material-icons align-middle" style="font-size: 18px;">visibility_off</i>
                                        Hide Private Key
                                    </p>
                                    <div class="alert alert-warning" style="word-break: break-all;">
                                        <small><strong>Private Key:</strong></small><br>
                                        <code id="walletPrivateKey">Loading...</code>
                                    </div>
                                    <button class="btn btn-outline-secondary btn-sm" onclick="copyPrivateKey()">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                        Copy Private Key
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Right side: Send Tokens -->
                        <div class="col-lg-6">
                            <h6 class="mb-3">
                                <i class="material-icons align-middle me-1">send</i>
                                Send SATORI
                            </h6>
                            <div class="mb-3">
                                <label class="form-label">Send From</label>
                                <div class="d-flex gap-3">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="sendSource" id="sendFromVault" value="vault" checked>
                                        <label class="form-check-label" for="sendFromVault">
                                            Vault <small class="text-muted" id="vaultBalanceLabel">(--)</small>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="sendSource" id="sendFromWallet" value="wallet">
                                        <label class="form-check-label" for="sendFromWallet">
                                            Identity Wallet <small class="text-muted" id="walletBalanceLabel">(--)</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Destination Address</label>
                                <input type="text" class="form-control" id="sendDestAddress" placeholder="Enter destination address (E...)">
                            </div>
                            <div class="row mb-3">
                                <div class="col-8">
                                    <label class="form-label">Amount</label>
                                    <input type="number" class="form-control" id="sendAmount" placeholder="0.00" step="0.00000001" min="0">
                                </div>
                                <div class="col-4">
                                    <label class="form-label">Sweep All</label>
                                    <div class="form-check mt-2">
                                        <input class="form-check-input" type="checkbox" id="sendSweep" onchange="toggleSweepAmount()">
                                        <label class="form-check-label" for="sendSweep">Send All</label>
                                    </div>
                                </div>
                            </div>
                            <button class="btn btn-primary w-100" onclick="sendTransaction()" id="sendBtn">
                                <i class="material-icons align-middle me-1">send</i>
                                Send Transaction
                            </button>
                            <div id="sendResult" class="mt-3" style="display: none;"></div>
                            <p class="text-muted small mt-3 mb-0">
                                Transaction fees will be paid during the send process. They typically amount to no more than 0.25 EVR.
                            </p>
                        </div>
                    </div>

                    <!-- Identity Wallet (Collapsed) -->
                    <div id="identityWalletSection" style="display: none;" class="mt-4 pt-4 border-top">
                        <h6 class="text-muted mb-3">
                            <i class="material-icons align-middle me-1">badge</i>
                            Identity Wallet (for digital identity only - do not send tokens here)
                        </h6>
                        <div class="row">
                            <div class="col-md-6 mb-3 mb-md-0">
                                <label class="form-label small">Identity Address</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="identityAddress" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('identityAddress')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <label class="form-label small">Identity Private Key</label>
                                <div class="input-group input-group-sm">
                                    <input type="password" class="form-control" id="identityPrivateKey" readonly placeholder="Click to reveal...">
                                    <button class="btn btn-outline-secondary" onclick="toggleIdentityPrivateKey()" title="Show/Hide">
                                        <i class="material-icons align-middle" style="font-size: 16px;" id="identityKeyIcon">visibility</i>
                                    </button>
                                    <button class="btn btn-outline-secondary" onclick="copyIdentityPrivateKey()" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Burn Address for Reverse Bridge Section -->
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">local_fire_department</i>
                        Burn Address for Reverse Bridge
                    </h5>
                </div>
                <div class="card-body">
                    <p class="text-muted mb-3">
                        Send SATORI tokens on Base chain to this address to bridge them back to Evrmore
                    </p>
                    <div class="mb-3">
                        <label class="form-label">Base Chain Burn Address</label>
                        <div class="input-group">
                            {% if eth_wallet_address %}
                            <input type="text" class="form-control" id="burnAddress" readonly value="{{ eth_wallet_address }}">
                            <button class="btn btn-outline-secondary" onclick="copyToClipboard('burnAddress')" title="Copy burn address">
                                <i class="material-icons align-middle">content_copy</i>
                            </button>
                            {% else %}
                            <input type="text" class="form-control" readonly value="Not available" disabled>
                            {% endif %}
                        </div>
                        <small class="text-muted">Ethereum address ending in "DEAD"</small>
                    </div>
                    <div class="alert alert-info" role="alert">
                        <strong>How it works:</strong>
                        <ol class="mb-0 mt-2">
                            <li>Send SATORI tokens to this burn address on the <strong>Base blockchain</strong></li>
                            <li>Tokens are tracked by the bridge system daily at 20:00 UTC</li>
                            <li>After 30 days, equivalent SATORI will be minted on Evrmore chain to your wallet</li>
                        </ol>
                    </div>
                    <div class="alert alert-danger" role="alert">
                        <i class="material-icons align-middle me-1" style="font-size: 18px;">warning</i>
                        <strong>Warning:</strong> Only send SATORI tokens from Base chain. Sending other tokens or from wrong networks will result in permanent loss.
                    </div>
                </div>
            </div>
        </div>

        <!-- Balance Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">account_balance_wallet</i>
                        Balance
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="refreshBalance()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="card-body">
                    <div class="row text-center py-3">
                        <div class="col-md-4 col-6 mb-3 mb-md-0">
                            <h3 id="tokenBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">SATORI Token</p>
                        </div>
                        <div class="col-md-4 col-6 mb-3 mb-md-0">
                            <h3 id="stakeBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">SATORI Stake</p>
                        </div>
                        <div class="col-md-4 col-12">
                            <h3 id="evrBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">Evrmore (EVR)</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Reward Address Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">card_giftcard</i>
                        Reward Address
                    </h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Current Address</label>
                        <input type="text" class="form-control" id="currentRewardAddress" readonly placeholder="Not set">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">New Address</label>
                        <input type="text" class="form-control" id="newRewardAddress" placeholder="Enter new reward address">
                    </div>
                    <button class="btn btn-primary" onclick="setRewardAddress()">Save Address</button>
                </div>
            </div>
        </div>

    </div>

    <!-- AI Engine Training Control Section -->
    <div class="row g-4 mt-2">
        <div class="col-12">
            <div class="card">
                <div class="card-header"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#aiEngineCollapse"
                     aria-expanded="false"
                     aria-controls="aiEngineCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">psychology</i>
                        AI Engine Training Frequency
                    </h5>
                </div>
                <div class="collapse" id="aiEngineCollapse">
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Training Frequency</label>
                        <div class="d-flex align-items-center gap-3">
                            <span class="text-muted small">Slow</span>
                            <input type="range" class="form-range flex-grow-1"
                                   id="trainingDelaySlider"
                                   min="0" max="100" step="1" value="50"
                                   oninput="updateTrainingDelayLabel(this.value)"
                                   onchange="setTrainingDelay(this.value)">
                            <span class="text-muted small">Fast</span>
                        </div>
                        <div class="text-center mt-2">
                            <span class="badge bg-secondary" id="trainingDelayLabel">10 minutes</span>
                        </div>
                        <small class="form-text text-muted">
                            Controls how frequently the AI engine trains new models.
                            Lower frequency = less CPU usage. Higher frequency = faster model improvements.
                        </small>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Engine Performance Dashboard -->
    <div class="row g-4 mt-2">
        <div class="col-12">
            <div class="card">
                <div class="card-header"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#performanceCollapse"
                     aria-expanded="false"
                     aria-controls="performanceCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">show_chart</i>
                        AI Engine Performance
                    </h5>
                </div>
                <div class="collapse" id="performanceCollapse">
                <div class="card-body">
                    <!-- Stats Summary -->
                    <div class="row mb-4" id="performanceStats">
                        <div class="col-md-4">
                            <div class="text-center p-3 bg-secondary bg-opacity-10 rounded">
                                <div class="text-muted small">Accuracy</div>
                                <div class="h4 mb-0" id="accuracyPct">--</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="text-center p-3 bg-secondary bg-opacity-10 rounded">
                                <div class="text-muted small">Avg Error</div>
                                <div class="h5 mb-0" id="avgError">--</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="text-center p-3 bg-secondary bg-opacity-10 rounded">
                                <div class="text-muted small">Avg Abs Error</div>
                                <div class="h5 mb-0" id="avgAbsError">--</div>
                            </div>
                        </div>
                    </div>

                    <!-- Predictions vs Observations Chart -->
                    <div class="mb-4">
                        <h6 class="mb-3">Predictions vs Observations</h6>
                        <div style="position: relative; height: 300px;">
                            <canvas id="predVsObsChart"></canvas>
                        </div>
                        <small class="text-muted">Last 100 data points</small>
                    </div>

                    <!-- Accuracy Over Time Chart -->
                    <div class="mb-3">
                        <h6 class="mb-3">Prediction Accuracy Over Time</h6>
                        <div style="position: relative; height: 300px;">
                            <canvas id="accuracyChart"></canvas>
                        </div>
                        <small class="text-muted">Absolute error between prediction and next observation</small>
                    </div>

                    <div class="text-center mt-3">
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshPerformance()">
                            <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                            Refresh Data
                        </button>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Disclaimer Footer -->
<div class="container-fluid py-3">
    <div class="card">
        <div class="card-header text-center"
             style="cursor: pointer;"
             data-bs-toggle="collapse"
             data-bs-target="#disclaimerCollapse"
             aria-expanded="false"
             aria-controls="disclaimerCollapse">
            <h6 class="mb-0 text-muted">
                <i class="material-icons align-middle me-2" style="font-size: 18px;">info</i>
                Disclaimer of Warranties and Limitation of Liability
            </h6>
        </div>
        <div class="collapse" id="disclaimerCollapse">
            <div class="card-body">
                <div class="disclaimer-content" style="font-size: 0.85rem; line-height: 1.6;">
                    <h6>1. DISCLAIMER OF WARRANTIES</h6>
                    <p><strong>AS IS:</strong> The Satori Neuron software ("Software") is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, whether express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose, title, and non-infringement.</p>
                    <p><strong>NO GUARANTEE:</strong> We do not guarantee that the Software will be uninterrupted, error-free, secure, or free of viruses or other harmful components.</p>
                    <p><strong>USER RESPONSIBILITY:</strong> The user is solely responsible for any damage to their device or loss of data that results from the use of the Software.</p>

                    <h6 class="mt-3">2. LIMITATION OF LIABILITY</h6>
                    <p><strong>NO LIABILITY FOR DAMAGES:</strong> In no event shall The Satori Association or its affiliates, officers, directors, employees, agents, or licensors be liable for any indirect, incidental, special, consequential, or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, use, goodwill, or other intangible losses, resulting from:</p>
                    <ul>
                        <li>Your use or inability to use the Software;</li>
                        <li>Any unauthorized access to or use of the Software;</li>
                        <li>Any interruption or cessation of transmission to or from the Software;</li>
                        <li>Any bugs, viruses, trojan horses, or the like that may be transmitted to or through the Software by any third party;</li>
                        <li>Any errors or omissions in any content or for any loss or damage incurred as a result of the use of any content posted, emailed, transmitted, or otherwise made available through the Software, whether based on warranty, contract, tort (including negligence), or any other legal theory, whether or not we have been informed of the possibility of such damage.</li>
                    </ul>

                    <h6 class="mt-3">3. MAXIMUM LIABILITY</h6>
                    <p><strong>LIMITATION CAP:</strong> Our maximum aggregate liability under or in connection with the Software, whether in contract, tort (including negligence), or otherwise, shall in no circumstances exceed the amount paid by you, if any, for accessing or using the Software.</p>

                    <h6 class="mt-3">4. EXCLUSIONS</h6>
                    <p><strong>APPLICABLE LAW:</strong> Some jurisdictions do not allow the exclusion of certain warranties or the limitation or exclusion of liability for incidental or consequential damages. Accordingly, some of the above limitations may not apply to you. In such jurisdictions, our liability will be limited to the fullest extent permitted by applicable law.</p>

                    <h6 class="mt-3">5. INDEMNIFICATION</h6>
                    <p><strong>USER INDEMNITY:</strong> You agree to indemnify, defend, and hold harmless The Satori Association and its affiliates, officers, directors, employees, agents, and licensors from and against any claims, liabilities, damages, losses, and expenses, including, without limitation, reasonable legal and accounting fees, arising out of or in any way connected with your access to or use of the Software, or your violation of these terms.</p>

                    <h6 class="mt-3">6. GOVERNING LAW</h6>
                    <p><strong>SWISS LAW:</strong> This Disclaimer of Warranties and Limitation of Liability shall be governed by and construed in accordance with the laws of Switzerland, without regard to its conflict of laws principles.</p>

                    <h6 class="mt-3">7. DISPUTE RESOLUTION</h6>
                    <p><strong>MEDIATION FIRST:</strong> Any disputes arising under or in connection with this Disclaimer of Warranties and Limitation of Liability shall first be attempted to be resolved through mediation. The parties agree to submit the dispute to a mutually agreed-upon mediator in Switzerland. If mediation fails to resolve the dispute, it shall then be resolved in the courts of Switzerland.</p>

                    <h6 class="mt-3">8. CONTACT INFORMATION</h6>
                    <p>For any inquiries regarding this Disclaimer of Warranties and Limitation of Liability, please contact:</p>
                    <p class="mb-0">
                        <strong>The Satori Association</strong><br>
                        <a href="mailto:disclaimer@satorinet.io">disclaimer@satorinet.io</a>
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Messages -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="statusToast" class="toast" role="alert">
        <div class="toast-header bg-dark text-white">
            <strong class="me-auto">Satori</strong>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body" id="toastMessage"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const API_URL = '/api';

    // Helper function to format balance values (removes trailing zeros)
    function formatBalance(value) {
        if (value === undefined || value === null) return '--';
        // Format to 8 decimals then parse to remove trailing zeros
        return parseFloat(parseFloat(value).toFixed(8)).toString();
    }

    // Get color for commission percentage (light green at 0% to red at 100%)
    function getCommissionColor(percentage) {
        // Clamp percentage between 0 and 100
        const p = Math.max(0, Math.min(100, percentage));

        // Light green (144, 238, 144) at 0% to red (220, 53, 69) at 100%
        const r = Math.round(144 + (220 - 144) * (p / 100));
        const g = Math.round(238 + (53 - 238) * (p / 100));
        const b = Math.round(144 + (69 - 144) * (p / 100));

        return `rgb(${r}, ${g}, ${b})`;
    }

    // State tracking for mutual exclusion
    let isStakingToPool = false;
    let isOpenPool = false;  // True if pool has commission > 0 (accepting pool stakers)
    let hasWorkers = false;  // True if user has workers (active pool)

    function showToast(message, isError = false) {
        const toast = document.getElementById('statusToast');
        const toastBody = document.getElementById('toastMessage');
        toastBody.textContent = message;
        toastBody.className = 'toast-body ' + (isError ? 'text-danger' : 'text-success');
        const bsToast = new bootstrap.Toast(toast);
        bsToast.show();
    }

    async function apiCall(endpoint, method = 'GET', data = null) {
        let isNetworkError = false;
        try {
            const options = {
                method: method,
                headers: {
                    'Content-Type': 'application/json'
                }
            };
            if (data) {
                options.body = JSON.stringify(data);
            }
            const response = await fetch(API_URL + endpoint, options);

            // If we got a response, server is reachable - update status to connected
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (indicator && text) {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
            }

            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                const text = await response.text();
                throw new Error(`Server returned non-JSON response: ${text.substring(0, 100)}`);
            }

            const result = await response.json();

            // Check for HTTP errors (but server is still connected)
            if (!response.ok) {
                // Handle error properly - could be string or object
                let errorMsg = `HTTP ${response.status}`;
                if (result.detail) {
                    errorMsg = typeof result.detail === 'object' ? JSON.stringify(result.detail) : result.detail;
                } else if (result.error) {
                    errorMsg = typeof result.error === 'object' ? JSON.stringify(result.error) : result.error;
                }
                throw new Error(errorMsg);
            }

            return result;
        } catch (error) {
            console.error('API Error:', error);

            // Only show "Disconnected" for network errors (not HTTP errors like 404, 401)
            // Network errors: TypeError (failed to fetch), timeout, connection refused
            if (error instanceof TypeError || error.message.includes('fetch') || error.message.includes('network')) {
                isNetworkError = true;
                const indicator = document.getElementById('statusIndicator');
                const text = document.getElementById('statusText');
                if (indicator && text) {
                    indicator.className = 'status-indicator status-offline';
                    text.textContent = 'Disconnected';
                }
            }

            // Ensure error message is always a string
            const errorMsg = error.message || String(error);
            showToast('API Error: ' + errorMsg, true);
            return null;
        }
    }

    // Update UI based on mutual exclusion rules
    function updateMutualExclusionUI() {
        const poolStakingReasonCommission = 'You cannot stake to a pool while you have commission set (open pool)';
        const poolStakingReasonWorkers = 'You cannot stake to a pool while you have workers (active pool)';

        // Pool Staking elements
        const poolAddressInput = document.getElementById('poolAddress');
        const poolAddressWrapper = document.getElementById('poolAddressWrapper');
        const addStakeBtn = document.getElementById('addStakeBtn');
        const addStakeBtnWrapper = document.getElementById('addStakeBtnWrapper');
        const removeStakeBtn = document.getElementById('removeStakeBtn');
        const removeStakeBtnWrapper = document.getElementById('removeStakeBtnWrapper');

        // Pool Management elements
        const poolCommission = document.getElementById('poolCommission');
        const poolCommissionWrapper = document.getElementById('poolCommissionWrapper');
        const newWorkerInput = document.getElementById('newWorkerAddress');
        const addWorkerBtn = document.getElementById('addWorkerBtn');
        const addWorkerWrapper = document.getElementById('addWorkerWrapper');

        // Pool Staking inputs are always enabled
        // (Commented out: previously disabled when user was a pool operator)
        /*
        if (isOpenPool || hasWorkers) {
            const reason = isOpenPool ? poolStakingReasonCommission : poolStakingReasonWorkers;
            poolAddressInput.disabled = true;
            poolAddressWrapper.setAttribute('title', reason);
            addStakeBtn.disabled = true;
            addStakeBtnWrapper.setAttribute('title', reason);
            removeStakeBtn.disabled = true;
            removeStakeBtnWrapper.setAttribute('title', reason);
        } else {
        */
            poolAddressInput.disabled = false;
            poolAddressWrapper.setAttribute('title', '');
            addStakeBtn.disabled = false;
            addStakeBtnWrapper.setAttribute('title', '');
            // Remove button only enabled if actually staking to a pool
            if (isStakingToPool) {
                removeStakeBtn.disabled = false;
                removeStakeBtnWrapper.setAttribute('title', '');
            } else {
                removeStakeBtn.disabled = true;
                removeStakeBtnWrapper.setAttribute('title', 'You are not currently staking to a pool');
            }
        // }

        // If staking to pool, dim Pool Management card and show notice
        const poolManagementBody = document.getElementById('poolManagementBody');
        const poolStakingNotice = document.getElementById('poolStakingNotice');

        if (isStakingToPool) {
            poolManagementBody.classList.add('dimmed');
            poolStakingNotice.style.display = 'block';
        } else {
            poolManagementBody.classList.remove('dimmed');
            poolStakingNotice.style.display = 'none';
        }

        // Update card collapse states based on usage
        updateCardCollapseStates();
    }

    function updateCardCollapseStates() {
        const poolStakingCollapse = document.getElementById('poolStakingCollapse');
        const poolManagementCollapse = document.getElementById('poolManagementCollapse');

        if (poolStakingCollapse) {
            // Show Pool Staking card if user is staking to a pool
            if (isStakingToPool) {
                poolStakingCollapse.classList.add('show');
            } else {
                poolStakingCollapse.classList.remove('show');
            }
        }

        if (poolManagementCollapse) {
            // Show Pool Management card if user is an open pool or has workers
            if (isOpenPool || hasWorkers) {
                poolManagementCollapse.classList.add('show');
            } else {
                poolManagementCollapse.classList.remove('show');
            }
        }
    }

    function setBalanceLoading(elementId, isLoading) {
        const element = document.getElementById(elementId);
        if (isLoading) {
            element.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span>';
        }
    }

    async function loadBalance() {
        // Load stake from Satori API server (only source for stake info)
        try {
            const result = await apiCall('/balance/get');
            if (result && result.stake !== undefined) {
                document.getElementById('stakeBalance').textContent = result.stake;
            } else {
                document.getElementById('stakeBalance').textContent = '--';
            }
        } catch (error) {
            console.error('Failed to load stake balance:', error);
            document.getElementById('stakeBalance').textContent = '--';
        }
    }

    async function refreshBalance() {
        // Get real-time balance from electrumx blockchain (wallet + vault)
        // Fetches SATORI token and EVR balance
        setBalanceLoading('tokenBalance', true);
        setBalanceLoading('evrBalance', true);

        try {
            const result = await apiCall('/wallet/balance/direct');
            if (result && !result.error) {
                document.getElementById('tokenBalance').textContent = result.total !== undefined ? formatBalance(result.total) : '--';
                document.getElementById('evrBalance').textContent = result.total_evr !== undefined ? formatBalance(result.total_evr) : '--';

                // Update balance labels in send section
                if (result.vault_balance !== undefined) {
                    document.getElementById('vaultBalanceLabel').textContent = '(' + formatBalance(result.vault_balance) + ')';
                }
                if (result.wallet_balance !== undefined) {
                    document.getElementById('walletBalanceLabel').textContent = '(' + formatBalance(result.wallet_balance) + ')';
                }
            } else {
                // If there's an error, show dashes
                document.getElementById('tokenBalance').textContent = '--';
                document.getElementById('evrBalance').textContent = '--';
                document.getElementById('vaultBalanceLabel').textContent = '(--)';
                document.getElementById('walletBalanceLabel').textContent = '(--)';
                if (result && result.error) {
                    console.error('ElectrumX balance fetch error:', result.error);
                }
            }
        } catch (error) {
            console.error('Failed to fetch balance from ElectrumX:', error);
            document.getElementById('tokenBalance').textContent = '--';
            document.getElementById('evrBalance').textContent = '--';
            document.getElementById('vaultBalanceLabel').textContent = '(--)';
            document.getElementById('walletBalanceLabel').textContent = '(--)';
        }
    }

    async function loadAllBalances() {
        // Load both stake (from API) and live balances (from ElectrumX)
        await Promise.all([
            loadBalance(),      // Stake from Satori API
            refreshBalance()    // SATORI and EVR from ElectrumX
        ]);
    }

    async function loadRewardAddress() {
        const result = await apiCall('/peer/reward-address');
        if (result && result.reward_address) {
            document.getElementById('currentRewardAddress').value = result.reward_address;
        }
    }

    async function setRewardAddress() {
        const address = document.getElementById('newRewardAddress').value.trim();
        if (!address) {
            showToast('Please enter an address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }

        // Check if same as current address
        const currentAddress = document.getElementById('currentRewardAddress').value;
        if (address === currentAddress) {
            showToast('This reward address is already set', true);
            document.getElementById('newRewardAddress').value = '';
            return;
        }

        // Backend handles server sync
        const result = await apiCall('/peer/reward-address', 'POST', { reward_address: address });
        if (result && result.success) {
            showToast('Reward address updated');
            loadRewardAddress();
            document.getElementById('newRewardAddress').value = '';
        }
    }

    async function loadStakingStatus() {
        // Get wallet address first
        const walletData = await apiCall('/wallet/address');
        if (!walletData || !walletData.wallet_address) {
            const statusEl = document.getElementById('stakingStatus');
            statusEl.className = 'alert alert-warning';
            statusEl.textContent = 'Unable to load staking status';
            return;
        }

        // Query lender status with wallet address
        const result = await apiCall(`/lender/status?wallet_address=${encodeURIComponent(walletData.wallet_address)}`);
        const statusEl = document.getElementById('stakingStatus');
        if (result && result.pool_address) {
            isStakingToPool = true;
            statusEl.className = 'alert alert-success';
            statusEl.textContent = 'Staking with pool: ' + result.pool_address;
            // Update the pool address input field
            document.getElementById('poolAddress').value = result.pool_address;
        } else {
            isStakingToPool = false;
            statusEl.className = 'alert alert-secondary';
            statusEl.textContent = 'Not staking with a pool';
            // Clear the pool address input field
            document.getElementById('poolAddress').value = '';
        }
        updateMutualExclusionUI();
    }

    async function addStakeToPool() {
        const pool = document.getElementById('poolAddress').value.trim();
        if (!pool) {
            showToast('Please enter a pool address', true);
            return;
        }
        if (!isValidAddress(pool)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        const result = await apiCall('/lender/lend', 'POST', { pool_address: pool });
        if (result) {
            showToast('Stake added to pool');
            loadStakingStatus();
        }
    }

    async function removeStakeFromPool() {
        const result = await apiCall('/lender/lend', 'DELETE');
        if (result) {
            showToast('Stake removed from pool');
            loadStakingStatus();
        }
    }

    async function loadAvailablePools() {
        const listEl = document.getElementById('availablePoolsList');
        listEl.innerHTML = '<div class="text-muted small p-2">Loading pools...</div>';

        const result = await apiCall('/pool/open', 'GET');
        if (result && result.pools && result.pools.length > 0) {
            listEl.innerHTML = '';
            // Sort pools by increasing fee percentage (inverted commission)
            result.pools.sort((a, b) => (100 - a.commission) - (100 - b.commission));
            result.pools.forEach(pool => {
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action';
                item.onclick = (e) => {
                    e.preventDefault();
                    document.getElementById('poolAddress').value = pool.address;
                };
                const invertedCommission = 100 - pool.commission;
                const commissionColor = getCommissionColor(invertedCommission);
                item.innerHTML = `
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <div>
                            <small class="text-muted">Address:</small><br>
                            <code class="small">${pool.address}</code>
                        </div>
                        <div class="text-end">
                            ${pool.alias ? `<span class="badge bg-primary">${pool.alias}</span><br>` : ''}
                            <small class="fw-bold" style="color: ${commissionColor}">${invertedCommission}% Fee</small>
                        </div>
                    </div>
                `;
                listEl.appendChild(item);
            });
        } else {
            listEl.innerHTML = '<div class="text-muted small p-2">No open pools available</div>';
        }
    }

    async function setPoolCommission() {
        const commissionInput = document.getElementById('poolCommission');
        let displayedCommission = commissionInput.value ? parseInt(commissionInput.value) : null;

        // Validate
        if (displayedCommission !== null && (displayedCommission < 0 || displayedCommission > 100)) {
            showToast('Commission must be between 0 and 100', true);
            return;
        }

        // Convert inverted value back to actual commission (100 - displayed)
        // Displayed 95% means pool stakers keep 95%, so commission is 5%
        let commission = displayedCommission !== null ? (100 - displayedCommission) : null;

        // Convert 100% commission (0% to stakers) to null (closed)
        if (commission === 100) {
            commission = null;
        }

        const result = await apiCall('/pool/toggle-open', 'POST', { commission: commission });
        if (result) {
            const msg = commission === null ? 'Pool closed' : `Pool open with ${displayedCommission}% Fee`;
            showToast(msg);
            await loadPoolCommission();
            await loadAvailablePools();  // Refresh pool list to show updated commission
            updateMutualExclusionUI();
        }
    }

    async function loadPoolCommission() {
        const result = await apiCall('/pool/commission', 'GET');
        if (result) {
            const commissionInput = document.getElementById('poolCommission');
            commissionInput.value = result.commission !== null ? (100 - result.commission) : '';
            isOpenPool = result.commission !== null && result.commission > 0;
            updateMutualExclusionUI();  // Update UI after setting isOpenPool
        }
    }

    async function loadWorkers() {
        const workerListEl = document.getElementById('workerList');
        const result = await apiCall('/pool/workers');

        if (result && result.workers && result.workers.length > 0) {
            hasWorkers = true;
            workerListEl.innerHTML = '';
            result.workers.forEach(worker => {
                const workerItem = document.createElement('div');
                workerItem.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';
                workerItem.innerHTML = `
                    <div>
                        <small class="text-muted">Address:</small><br>
                        <code class="small">${worker.address}</code>
                        ${worker.alias ? `<br><span class="badge bg-secondary">${worker.alias}</span>` : ''}
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeWorker('${worker.address}')">
                        <i class="material-icons align-middle" style="font-size: 16px;">delete</i>
                    </button>
                `;
                workerListEl.appendChild(workerItem);
            });
        } else {
            hasWorkers = false;
            workerListEl.innerHTML = '<p class="text-muted">No workers</p>';
        }

        updateMutualExclusionUI();
    }

    async function loadLenders() {
        const lenderListEl = document.getElementById('lenderList');
        const result = await apiCall('/pool/lenders');

        if (result && result.lenders && result.lenders.length > 0) {
            lenderListEl.innerHTML = '';
            result.lenders.forEach(lender => {
                const lenderItem = document.createElement('div');
                lenderItem.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';
                lenderItem.innerHTML = `
                    <div>
                        <small class="text-muted">Address:</small><br>
                        <code class="small">${lender.address}</code>
                        ${lender.alias ? `<br><span class="badge bg-secondary">${lender.alias}</span>` : ''}
                    </div>
                `;
                lenderListEl.appendChild(lenderItem);
            });
        } else {
            lenderListEl.innerHTML = '<p class="text-muted">No pool stakers</p>';
        }
    }

    // Get central-lite API URL
    function getCentralApiUrl() {
        // Always use the production Satori network server for audit files
        return 'https://network.satorinet.io';
    }

    // Helper function to download JSON data as a file
    function downloadJSON(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Download workers audit
    async function downloadWorkersAudit() {
        try {
            const centralApiUrl = getCentralApiUrl();
            const response = await fetch(`${centralApiUrl}/api/v1/audit/workers/latest`);

            if (!response.ok) {
                if (response.status === 404) {
                    showToast('No workers audit available yet', 'warning');
                    return;
                }
                throw new Error(`HTTP ${response.status}`);
            }

            const csvText = await response.text();

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `workers_audit_${timestamp}.csv`;

            // Download CSV file
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            showToast('Workers audit downloaded');
        } catch (error) {
            console.error('Error downloading workers audit:', error);
            showToast('Failed to download workers audit', 'error');
        }
    }

    // Download pool stakers audit
    async function downloadLendersAudit() {
        try {
            const centralApiUrl = getCentralApiUrl();
            const response = await fetch(`${centralApiUrl}/api/v1/audit/stakers/latest`);

            if (!response.ok) {
                if (response.status === 404) {
                    showToast('No pool stakers audit available yet', 'warning');
                    return;
                }
                throw new Error(`HTTP ${response.status}`);
            }

            const csvText = await response.text();

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `stakers_audit_${timestamp}.csv`;

            // Download CSV file
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            showToast('Pool stakers audit downloaded');
        } catch (error) {
            console.error('Error downloading pool stakers audit:', error);
            showToast('Failed to download pool stakers audit', 'error');
        }
    }

    function isValidAddress(address) {
        return address && address.length === 34 && address.startsWith('E');
    }

    async function addWorker() {
        const address = document.getElementById('newWorkerAddress').value.trim();
        if (!address) {
            showToast('Please enter a worker address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        const result = await apiCall('/pool/worker', 'POST', { worker_address: address });
        if (result) {
            showToast('Worker added');
            document.getElementById('newWorkerAddress').value = '';
            loadWorkers();
        }
    }

    async function removeWorker(address) {
        const result = await apiCall(`/pool/worker/${address}`, 'DELETE');
        if (result) {
            showToast('Worker removed');
            loadWorkers();
        }
    }

    async function checkHealth() {
        try {
            const response = await fetch('/health');
            const data = await response.json();
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (data.api === 'connected') {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
            } else {
                indicator.className = 'status-indicator status-offline';
                text.textContent = 'Disconnected';
            }
        } catch (error) {
            document.getElementById('statusIndicator').className = 'status-indicator status-offline';
            document.getElementById('statusText').textContent = 'Disconnected';
        }
    }

    async function loadWalletAddresses() {
        const result = await apiCall('/wallet/address');
        if (result) {
            // Main wallet uses vault address
            if (result.vault_address) {
                document.getElementById('walletAddress').value = result.vault_address;
                loadQrCode(result.vault_address);
            } else {
                document.getElementById('walletAddress').value = 'Not available';
                document.getElementById('walletQrCode').innerHTML = '<p class="text-muted mb-0">No address</p>';
            }
            // Identity wallet (for backup)
            if (result.wallet_address) {
                document.getElementById('identityAddress').value = result.wallet_address;
            } else {
                document.getElementById('identityAddress').value = 'Not available';
            }
        }
    }

    // Identity Wallet functions
    let identityWalletVisible = false;
    let identityPrivateKeyLoaded = false;
    let identityPrivateKeyVisible = false;

    function toggleIdentityWallet() {
        const section = document.getElementById('identityWalletSection');
        identityWalletVisible = !identityWalletVisible;
        section.style.display = identityWalletVisible ? 'block' : 'none';
    }

    async function toggleIdentityPrivateKey() {
        const input = document.getElementById('identityPrivateKey');
        const icon = document.getElementById('identityKeyIcon');

        if (!identityPrivateKeyLoaded) {
            // Load the identity private key from API
            const result = await apiCall('/wallet/identity-private-key');
            if (result && result.private_key) {
                input.value = result.private_key;
                identityPrivateKeyLoaded = true;
            } else {
                input.value = 'Unable to load';
            }
        }

        identityPrivateKeyVisible = !identityPrivateKeyVisible;
        input.type = identityPrivateKeyVisible ? 'text' : 'password';
        icon.textContent = identityPrivateKeyVisible ? 'visibility_off' : 'visibility';
    }

    function copyIdentityPrivateKey() {
        const input = document.getElementById('identityPrivateKey');
        if (input.value && input.value !== 'Click to reveal...' && input.value !== 'Unable to load') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(input.value).then(() => {
                    showToast('Identity private key copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    input.select();
                    try {
                        document.execCommand('copy');
                        showToast('Identity private key copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy', true);
                    }
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                input.select();
                try {
                    document.execCommand('copy');
                    showToast('Identity private key copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy', true);
                }
            }
        } else {
            showToast('Please reveal the private key first', true);
        }
    }

    function copyToClipboard(elementId) {
        const input = document.getElementById(elementId);
        const value = input.value;
        if (value && value !== 'Loading...' && value !== 'Not available') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(value).then(() => {
                    showToast('Address copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    try {
                        input.select();
                        document.execCommand('copy');
                        showToast('Address copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy address', true);
                    }
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                try {
                    input.select();
                    document.execCommand('copy');
                    showToast('Address copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy address', true);
                }
            }
        } else {
            showToast('No address to copy', true);
        }
    }

    // Wallet Card Functions
    let privateKeyLoaded = false;

    async function loadQrCode(address) {
        const qrContainer = document.getElementById('walletQrCode');
        const result = await apiCall('/wallet/qr/' + encodeURIComponent(address));
        if (result && result.qr_code) {
            qrContainer.innerHTML = '<img src="' + result.qr_code + '" alt="QR Code" style="max-width: 150px;">';
        } else {
            qrContainer.innerHTML = '<p class="text-muted mb-0">QR code unavailable</p>';
        }
    }

    async function togglePrivateKey() {
        const showBtn = document.getElementById('showPrivateKeyBtn');
        const section = document.getElementById('privateKeySection');

        if (section.style.display === 'none') {
            // Show private key (vault private key)
            if (!privateKeyLoaded) {
                const result = await apiCall('/wallet/private-key');
                if (result && result.private_key) {
                    document.getElementById('walletPrivateKey').textContent = result.private_key;
                    privateKeyLoaded = true;
                } else {
                    document.getElementById('walletPrivateKey').textContent = 'Unable to load private key';
                }
            }
            showBtn.style.display = 'none';
            section.style.display = 'block';
        } else {
            // Hide private key
            showBtn.style.display = 'block';
            section.style.display = 'none';
        }
    }

    function copyPrivateKey() {
        const privateKey = document.getElementById('walletPrivateKey').textContent;
        if (privateKey && privateKey !== 'Loading...' && privateKey !== 'Unable to load private key') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(privateKey).then(() => {
                    showToast('Private key copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    const textArea = document.createElement('textarea');
                    textArea.value = privateKey;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showToast('Private key copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy private key', true);
                    }
                    document.body.removeChild(textArea);
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                const textArea = document.createElement('textarea');
                textArea.value = privateKey;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast('Private key copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy private key', true);
                }
                document.body.removeChild(textArea);
            }
        }
    }

    function toggleSweepAmount() {
        const sweepCheckbox = document.getElementById('sendSweep');
        const amountInput = document.getElementById('sendAmount');
        if (sweepCheckbox.checked) {
            amountInput.disabled = true;
            amountInput.value = '';
            amountInput.placeholder = 'All tokens';
        } else {
            amountInput.disabled = false;
            amountInput.placeholder = '0.00';
        }
    }

    async function sendTransaction() {
        const address = document.getElementById('sendDestAddress').value.trim();
        const amount = document.getElementById('sendAmount').value;
        const sweep = document.getElementById('sendSweep').checked;
        const sendBtn = document.getElementById('sendBtn');
        const resultDiv = document.getElementById('sendResult');

        // Get selected source (wallet or vault)
        const sendSource = document.querySelector('input[name="sendSource"]:checked').value;
        const sourceName = sendSource === 'wallet' ? 'Identity Wallet' : 'Vault';

        // Validate
        if (!address) {
            showToast('Please enter a destination address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        if (!sweep && (!amount || parseFloat(amount) <= 0)) {
            showToast('Please enter an amount or select "Send All"', true);
            return;
        }

        // Confirm with source information
        const confirmMsg = sweep
            ? 'Send ALL tokens from ' + sourceName + ' to ' + address + '?'
            : 'Send ' + amount + ' SATORI from ' + sourceName + ' to ' + address + '?';
        if (!confirm(confirmMsg)) {
            return;
        }

        // Send
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Sending...';
        resultDiv.style.display = 'none';

        try {
            const data = { address: address, sweep: sweep };
            if (!sweep) {
                data.amount = parseFloat(amount);
            }

            // Use the appropriate endpoint based on source selection
            const endpoint = sendSource === 'wallet' ? '/wallet/send-from-wallet' : '/wallet/send';
            const result = await apiCall(endpoint, 'POST', data);

            if (result && result.success) {
                resultDiv.className = 'mt-3 alert alert-success';
                resultDiv.innerHTML = '<strong>Success!</strong><br>Sent from ' + sourceName + '<br>Transaction ID: <code style="word-break: break-all;">' + result.txid + '</code>';
                resultDiv.style.display = 'block';
                showToast('Transaction sent successfully from ' + sourceName + '!');
                // Clear form
                document.getElementById('sendDestAddress').value = '';
                document.getElementById('sendAmount').value = '';
                document.getElementById('sendSweep').checked = false;
                toggleSweepAmount();
                // Refresh balances to show updated amounts
                refreshBalance();
            } else {
                const errorMsg = result ? (result.error || 'Transaction failed') : 'Transaction failed';
                resultDiv.className = 'mt-3 alert alert-danger';
                resultDiv.innerHTML = '<strong>Error:</strong> ' + errorMsg;
                resultDiv.style.display = 'block';
                showToast('Transaction failed: ' + errorMsg, true);
            }
        } catch (error) {
            resultDiv.className = 'mt-3 alert alert-danger';
            resultDiv.innerHTML = '<strong>Error:</strong> ' + error.message;
            resultDiv.style.display = 'block';
            showToast('Transaction error: ' + error.message, true);
        } finally {
            sendBtn.disabled = false;
            sendBtn.innerHTML = '<i class="material-icons align-middle me-1">send</i> Send Transaction';
        }
    }

    // AI Engine Training Frequency Control
    function sliderToSeconds(sliderValue) {
        // Convert slider percentage to seconds (non-linear logarithmic scale)
        // 0% = 24 hours, 25% = 1 hour, 50% = 10 min, 75% = 1 min, 100% = 0 sec
        const percentage = sliderValue / 100.0;

        if (percentage <= 0.0) return 86400;  // 24 hours
        if (percentage >= 1.0) return 0;      // continuous

        // Improved logarithmic scale using exponential decay
        // Maps 0%->86400s (24h), 50%->675s (~11min), 100%->0s (continuous)
        const delay = Math.round(86400 * Math.pow(1 - percentage, 7));
        return delay;
    }

    function secondsToSlider(seconds) {
        // Convert seconds to slider percentage (inverse of sliderToSeconds)
        if (seconds >= 86400) return 0;
        if (seconds <= 0) return 100;

        // Inverse of logarithmic scale
        const percentage = 1 - Math.pow(seconds / 86400, 1/7);
        return Math.round(percentage * 100);
    }

    function formatDelay(seconds) {
        // Format seconds into human-readable string
        if (seconds === 0) return "Continuous";
        if (seconds < 60) return seconds + " seconds";
        if (seconds < 3600) return Math.round(seconds / 60) + " minutes";
        if (seconds < 86400) return Math.round(seconds / 3600) + " hours";
        return Math.round(seconds / 86400) + " days";
    }

    function updateTrainingDelayLabel(sliderValue) {
        // Update label as slider moves
        const seconds = sliderToSeconds(sliderValue);
        document.getElementById('trainingDelayLabel').textContent = formatDelay(seconds);
    }

    async function setTrainingDelay(sliderValue) {
        // Save to backend when slider changes
        const seconds = sliderToSeconds(sliderValue);

        try {
            const result = await apiCall('/engine/training-delay', 'POST', {
                delay_seconds: seconds
            });

            if (result && !result.error) {
                showToast(`Training frequency updated: ${formatDelay(seconds)}`);
            } else {
                showToast('Failed to update training frequency', true);
            }
        } catch (error) {
            console.error('Error setting training delay:', error);
            showToast('Failed to update training frequency', true);
        }
    }

    async function loadTrainingDelay() {
        // Load current setting on page load
        try {
            const result = await apiCall('/engine/training-delay');

            if (result && result.delay_seconds !== undefined) {
                const sliderValue = secondsToSlider(result.delay_seconds);
                document.getElementById('trainingDelaySlider').value = sliderValue;
                updateTrainingDelayLabel(sliderValue);
            }
        } catch (error) {
            console.error('Error loading training delay:', error);
        }
    }

    // AI Engine Performance Charts
    let predVsObsChart = null;
    let accuracyChart = null;

    async function loadPerformance() {
        try {
            const data = await apiCall('/engine/performance');

            if (!data || data.error) {
                // Show message to user
                if (data?.error) {
                    showToast('Performance data unavailable: ' + data.error, true);
                }
                return;
            }

            // Check if we have any data
            const hasData = (data.observations && data.observations.length > 0) ||
                           (data.predictions && data.predictions.length > 0);

            if (!hasData) {
                // Update stats to show no data
                document.getElementById('accuracyPct').textContent = '--';
                document.getElementById('avgError').textContent = 'No data yet';
                document.getElementById('avgAbsError').textContent = '--';
                return;
            }

            // Update stats
            if (data.stats) {
                document.getElementById('accuracyPct').textContent =
                    data.stats.accuracy_pct ? `${data.stats.accuracy_pct}%` : '--';
                document.getElementById('avgError').textContent =
                    data.stats.avg_error !== undefined ? data.stats.avg_error.toFixed(2) : '--';
                document.getElementById('avgAbsError').textContent =
                    data.stats.avg_abs_error !== undefined ? data.stats.avg_abs_error.toFixed(2) : '--';
            }

            renderPredVsObsChart(data.observations, data.predictions, data.accuracy);
            renderAccuracyChart(data.accuracy);
        } catch (error) {
            console.error('Error loading performance data:', error);
            showToast('Failed to load performance data', true);
        }
    }

    function renderPredVsObsChart(observations, predictions, accuracyData) {
        try {
            const ctx = document.getElementById('predVsObsChart');
            if (!ctx) {
                console.error('Chart canvas element not found: predVsObsChart');
                return;
            }

            if (predVsObsChart) predVsObsChart.destroy();

            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#a0a0a0' : '#555555';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)';

            // Helper function to parse timestamp (handles both Unix timestamps and date strings)
            const parseTimestamp = (ts) => {
                // Check if it's a pure numeric string (Unix timestamp)
                if (/^\d+\.?\d*$/.test(ts)) {
                    const numTs = parseFloat(ts);
                    // Unix timestamp - multiply by 1000 if in seconds
                    return numTs < 10000000000 ? new Date(numTs * 1000) : new Date(numTs);
                } else {
                    // Date string (like "2025-12-21 06:55:47.484299")
                    // Add 'Z' to parse as UTC if not already present
                    const dateStr = ts.includes('Z') ? ts : ts.replace(' ', 'T') + 'Z';
                    return new Date(dateStr);
                }
            };

            // Convert observations data - use sequential positions
            const obsData = observations.map((o, i) => ({
                x: i,  // Use index as x-position
                y: parseFloat(o.value)
            }));

            // Convert predictions data - shift forward by 1 position
            // prediction[i] should be at position i+1 to align with observation[i+1]
            const predData = predictions.map((p, i) => ({
                x: i + 1,  // Shift forward: pred[0] at position 1, pred[1] at position 2, etc.
                y: parseFloat(p.value)
            }));

            // Create index-based lookup maps
            // observation[i] -> prediction[i+1] (observation produces next prediction)
            // prediction[i] -> observation[i-1] (prediction was made from previous observation)
            const obsToPredMap = new Map();
            const predToObsMap = new Map();

            // Build obsToPredMap: observation[i] maps to prediction[i+1]
            observations.forEach((obs, i) => {
                if (i + 1 < predictions.length) {
                    const nextPred = predictions[i + 1];
                    obsToPredMap.set(obs.ts, {
                        ts: nextPred.ts,
                        value: parseFloat(nextPred.value),
                        timestamp: parseTimestamp(nextPred.ts)
                    });
                }
                // First observation has no prediction to show (it produces the next one)
            });

            // Build predToObsMap: prediction[i] maps to observation[i-1]
            predictions.forEach((pred, i) => {
                if (i - 1 >= 0 && i - 1 < observations.length) {
                    const prevObs = observations[i - 1];
                    predToObsMap.set(pred.ts, {
                        ts: prevObs.ts,
                        value: parseFloat(prevObs.value),
                        timestamp: parseTimestamp(prevObs.ts)
                    });
                }
                // First prediction has no prior observation in our data
            });

            predVsObsChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Observations',
                    data: obsData,
                    borderColor: 'rgb(75, 192, 192)',
                    borderWidth: 2,
                    pointRadius: 2
                }, {
                    label: 'Predictions',
                    data: predData,
                    borderColor: 'rgb(153, 102, 255)',
                    borderWidth: 2,
                    pointRadius: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            color: textColor,
                            callback: function(value, index) {
                                // Show timestamp labels for select points
                                if (index >= observations.length - 3 || index === 0) {
                                    const obs = observations[value];
                                    if (obs) {
                                        return new Date(parseTimestamp(obs.ts)).toLocaleTimeString();
                                    }
                                }
                                return '';
                            }
                        },
                        grid: { color: gridColor }
                    },
                    y: {
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        mode: 'point',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = Math.round(tooltipItems[0].parsed.x);
                                const obs = observations[index];
                                if (obs) {
                                    return new Date(parseTimestamp(obs.ts)).toLocaleString();
                                }
                                return 'Index: ' + index;
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label;
                                const value = context.parsed.y;
                                const position = Math.round(context.parsed.x);

                                if (datasetLabel === 'Observations') {
                                    // observation is at position i
                                    const obsData = observations[position];
                                    if (!obsData) {
                                        // No observation at this position (future prediction only)
                                        return null;
                                    }
                                    const obsTime = new Date(parseTimestamp(obsData.ts)).toLocaleTimeString();
                                    return `Observation: ${value.toFixed(2)} (at ${obsTime})`;

                                } else if (datasetLabel === 'Predictions') {
                                    // prediction[i] is at position i+1, so prediction at position p is predictions[p-1]
                                    const predIndex = position - 1;
                                    if (predIndex < 0 || predIndex >= predictions.length) {
                                        // No prediction at this position (first observation has no prediction)
                                        return null;
                                    }
                                    const predData = predictions[predIndex];
                                    if (!predData) {
                                        return null;
                                    }
                                    const predTime = new Date(parseTimestamp(predData.ts)).toLocaleTimeString();
                                    return `Prediction: ${value.toFixed(2)} (at ${predTime})`;
                                }

                                return null;
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'point',
                    intersect: false
                }
            }
        });
        } catch (error) {
            console.error('Error rendering predictions vs observations chart:', error);
            showToast('Error rendering chart: ' + error.message, true);
        }
    }

    function renderAccuracyChart(accuracyData) {
        try {
            const ctx = document.getElementById('accuracyChart');
            if (!ctx) {
                console.error('Chart canvas element not found: accuracyChart');
                return;
            }

            if (accuracyChart) accuracyChart.destroy();

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const textColor = isDark ? '#a0a0a0' : '#555555';
        const gridColor = isDark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)';

        // Helper function to parse timestamp (same as in renderPredVsObsChart)
        const parseTimestamp = (ts) => {
            if (/^\d+\.?\d*$/.test(ts)) {
                const numTs = parseFloat(ts);
                return numTs < 10000000000 ? new Date(numTs * 1000) : new Date(numTs);
            } else {
                const dateStr = ts.includes('Z') ? ts : ts.replace(' ', 'T') + 'Z';
                return new Date(dateStr);
            }
        };

        accuracyChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Absolute Error',
                    data: accuracyData.map((a, i) => ({ x: i, y: a.abs_error })),
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 2,
                    pointRadius: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            color: textColor,
                            callback: function(value, index) {
                                // Show timestamp labels for select points
                                if (index >= accuracyData.length - 3 || index === 0) {
                                    const acc = accuracyData[value];
                                    if (acc) {
                                        return parseTimestamp(acc.ts).toLocaleTimeString();
                                    }
                                }
                                return '';
                            }
                        },
                        grid: { color: gridColor }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = Math.round(tooltipItems[0].parsed.x);
                                const acc = accuracyData[index];
                                if (acc) {
                                    return parseTimestamp(acc.ts).toLocaleString();
                                }
                                return 'Index: ' + index;
                            },
                            label: function(context) {
                                return 'Absolute Error: ' + context.parsed.y.toFixed(4);
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
        });
        } catch (error) {
            console.error('Error rendering accuracy chart:', error);
            showToast('Error rendering accuracy chart: ' + error.message, true);
        }
    }

    function refreshPerformance() {
        showToast('Refreshing performance data...', 'info');
        loadPerformance();
    }

    // Wallet Import Functionality
    let walletImportFilesModal = [];

    function openImportWalletModal() {
        const modal = new bootstrap.Modal(document.getElementById('importWalletModal'));
        modal.show();
    }

    function handleWalletFolderSelectModal(event) {
        const files = Array.from(event.target.files);
        const importBtn = document.getElementById('importWalletBtnModal');
        const fileListDiv = document.getElementById('importFileListModal');
        const fileListItems = document.getElementById('importFileListItemsModal');

        walletImportFilesModal = [];
        fileListItems.innerHTML = '';

        if (files.length === 0) {
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Validate folder name is "wallet"
        const firstFile = files[0];
        const pathParts = firstFile.webkitRelativePath.split('/');
        const folderName = pathParts[0];

        if (folderName !== 'wallet') {
            showToast('Please select a folder named "wallet"', true);
            event.target.value = '';
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Filter to only .yaml files
        const yamlFiles = files.filter(f =>
            f.name.endsWith('.yaml') || f.name.endsWith('.yml')
        );

        // Check for required files
        const fileNames = yamlFiles.map(f => f.name);
        const hasWallet = fileNames.includes('wallet.yaml');
        const hasVault = fileNames.includes('vault.yaml');

        if (!hasWallet || !hasVault) {
            showToast('Wallet folder must contain wallet.yaml and vault.yaml', true);
            event.target.value = '';
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Valid files - show list
        walletImportFilesModal = yamlFiles;
        fileListItems.innerHTML = '';
        yamlFiles.forEach(file => {
            const li = document.createElement('li');
            li.innerHTML = `<code>${file.name}</code> (${(file.size / 1024).toFixed(2)} KB)`;
            fileListItems.appendChild(li);
        });

        fileListDiv.style.display = 'block';
        importBtn.disabled = false;
    }

    async function importWalletFromModal() {
        if (walletImportFilesModal.length === 0) {
            showToast('No files selected', true);
            return;
        }

        const importBtn = document.getElementById('importWalletBtnModal');
        const resultDiv = document.getElementById('importResultModal');

        // Confirm action
        const confirmMsg =
            'WARNING: This will replace your current wallet and restart the container!\n\n' +
            `Files to import: ${walletImportFilesModal.map(f => f.name).join(', ')}\n\n` +
            'Make sure you have backed up your current wallet.\n\n' +
            'Continue?';

        if (!confirm(confirmMsg)) {
            return;
        }

        // Disable button and show loading
        importBtn.disabled = true;
        importBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Importing...';
        resultDiv.style.display = 'none';

        try {
            // Prepare FormData
            const formData = new FormData();
            walletImportFilesModal.forEach(file => {
                formData.append('files', file, file.name);
            });

            // Upload files
            const response = await fetch('/api/wallet/import', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (response.ok && data.success) {
                resultDiv.className = 'mt-3 alert alert-success';
                resultDiv.innerHTML =
                    '<strong>Success!</strong><br>' +
                    'Wallet imported successfully.<br>' +
                    'Container is restarting...<br>' +
                    '<small>Backup saved to: ' + data.backup_location + '</small><br>' +
                    '<small class="text-warning">Note: You\'ll need to set a new reward address after restart.</small>';
                resultDiv.style.display = 'block';

                showToast('Wallet imported! Container restarting...');

                // Show restart notice
                setTimeout(() => {
                    alert(
                        'Container Restarting\n\n' +
                        'The application is restarting with your imported wallet.\n' +
                        'Please wait 10-15 seconds, then refresh this page.\n\n' +
                        'You will need to:\n' +
                        '1. Log in again with your vault password\n' +
                        '2. Set a new reward address for this wallet'
                    );

                    // Auto-reload after 15 seconds
                    setTimeout(() => {
                        window.location.href = '/login';
                    }, 15000);
                }, 2000);

            } else {
                const errorMsg = data.error || 'Import failed';
                const rolledBack = data.rolled_back ? '\n\nYour old wallet has been restored.' : '';
                resultDiv.className = 'mt-3 alert alert-danger';
                resultDiv.innerHTML = '<strong>Error:</strong> ' + errorMsg + rolledBack;
                resultDiv.style.display = 'block';
                showToast('Import failed: ' + errorMsg, true);

                // Re-enable button
                importBtn.disabled = false;
                importBtn.innerHTML = '<i class="material-icons align-middle me-1">upload</i> Import Wallet & Restart';
            }

        } catch (error) {
            resultDiv.className = 'mt-3 alert alert-danger';
            resultDiv.innerHTML = '<strong>Error:</strong> ' + error.message;
            resultDiv.style.display = 'block';
            showToast('Import error: ' + error.message, true);

            // Re-enable button
            importBtn.disabled = false;
            importBtn.innerHTML = '<i class="material-icons align-middle me-1">upload</i> Import Wallet & Restart';
        }
    }

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
        // Set up wallet import file input handler for modal
        const walletFolderInputModal = document.getElementById('walletFolderInputModal');
        if (walletFolderInputModal) {
            walletFolderInputModal.addEventListener('change', handleWalletFolderSelectModal);
        }

        // Update theme icon based on stored theme
        const storedTheme = localStorage.getItem('satori-theme') || 'dark';
        const themeIcon = document.getElementById('themeIcon');
        if (themeIcon) {
            themeIcon.textContent = storedTheme === 'dark' ? 'light_mode' : 'dark_mode';
        }

        // Initialize Bootstrap tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // Ensure both pool cards start collapsed (will be expanded by API calls if needed)
        const poolStakingCollapse = document.getElementById('poolStakingCollapse');
        const poolManagementCollapse = document.getElementById('poolManagementCollapse');
        if (poolStakingCollapse) {
            poolStakingCollapse.classList.remove('show');
        }
        if (poolManagementCollapse) {
            poolManagementCollapse.classList.remove('show');
        }

        // Health check disabled to reduce API load
        // checkHealth();
        loadWalletAddresses();
        loadAllBalances();  // Load both stake and live balances from ElectrumX
        loadRewardAddress();
        // Staking/pool API calls moved to dedicated Stake Management page
        // loadStakingStatus();
        // loadWorkers();
        // loadLenders();
        // loadAvailablePools();
        // loadPoolCommission();
        loadTrainingDelay();  // Load AI engine training frequency setting
        loadPerformance();  // Load AI engine performance charts

        // Periodic health check - Disabled to reduce unnecessary load
        // setInterval(checkHealth, 30000);
    });
</script>
{% endblock %}
