{% extends "base.html" %}

{% block title %}Satori - Dashboard{% endblock %}

{% block content %}
<!-- Navigation -->
<nav class="navbar navbar-expand-lg px-4">
    <span class="navbar-brand">
        Satori
        <small class="text-muted ms-2" style="font-size: 0.65rem; font-weight: 400; opacity: 0.6;">{{ version }}</small>
    </span>
    <div class="ms-auto d-flex align-items-center">
        <!-- Connected Status (left of wallet) -->
        <span class="me-3">
            <span class="status-indicator status-online" id="statusIndicator"></span>
            <span id="statusText">Connected</span>
        </span>
        <!-- Wallet Dropdown -->
        <div class="dropdown me-3">
            <button class="btn btn-outline-light btn-sm dropdown-toggle" type="button" id="walletDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                <i class="material-icons align-middle" style="font-size: 16px;">account_balance_wallet</i>
                Wallet
            </button>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="walletDropdown" style="background: var(--bg-card); border: 1px solid var(--border-color);">
                <li>
                    <a class="dropdown-item" href="#" onclick="openImportWalletModal(); return false;" style="color: var(--text-primary);">
                        <i class="material-icons align-middle me-2" style="font-size: 18px;">upload_file</i>
                        Import Wallet
                    </a>
                </li>
            </ul>
        </div>
        <!-- Navigation Links -->
        <a href="{{ url_for('network') }}" class="btn btn-outline-light btn-sm me-2" title="P2P Network Dashboard">
            <i class="material-icons align-middle" style="font-size: 16px;">hub</i>
            Network
        </a>
        <a href="{{ url_for('oracle_page') }}" class="btn btn-outline-light btn-sm me-2" title="Oracle - Publish Data Streams">
            <i class="material-icons align-middle" style="font-size: 16px;">cloud_upload</i>
            Oracle
        </a>
        <a href="{{ url_for('predictions_page') }}" class="btn btn-outline-light btn-sm me-2" title="Predictions - Make & View Predictions">
            <i class="material-icons align-middle" style="font-size: 16px;">trending_up</i>
            Predictions
        </a>
        <a href="{{ url_for('governance') }}" class="btn btn-outline-light btn-sm me-2" title="Governance">
            <i class="material-icons align-middle" style="font-size: 16px;">how_to_vote</i>
            Governance
        </a>
        {% if is_signer %}
        <a href="{{ url_for('signer_dashboard') }}" class="btn btn-outline-light btn-sm me-2" title="Signer - Multi-sig Distribution">
            <i class="material-icons align-middle" style="font-size: 16px;">key</i>
            Signer
        </a>
        {% endif %}
        <a href="{{ url_for('stake_management') }}" class="btn btn-outline-light btn-sm me-2" title="Stake Management">
            <i class="material-icons align-middle" style="font-size: 16px;">handshake</i>
            Stake
        </a>
        <a href="{{ url_for('badges_page') }}" class="btn btn-outline-light btn-sm me-2" title="Badges & Achievements">
            <i class="material-icons align-middle" style="font-size: 16px;">military_tech</i>
            Badges
        </a>
        <a href="{{ url_for('donate') }}" class="btn btn-outline-light btn-sm me-2" title="Donate to Treasury">
            <i class="material-icons align-middle" style="font-size: 16px;">volunteer_activism</i>
            Donate
        </a>
        <a href="{{ url_for('guide') }}" class="btn btn-outline-light btn-sm me-2" title="Rewards Guide">
            <i class="material-icons align-middle" style="font-size: 16px;">menu_book</i>
            Guide
        </a>
        <a href="{{ url_for('restart_neuron') }}" class="btn btn-outline-light btn-sm me-2" title="Restart Node" onclick="return confirm('Restart your Satori node?');">
            <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
        </a>
        <a href="{{ url_for('logout') }}" class="btn btn-outline-light btn-sm me-2">Logout</a>
        <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark/light mode">
            <i class="material-icons" id="themeIcon">light_mode</i>
        </button>
    </div>
</nav>

<!-- Import Wallet Modal -->
<div class="modal fade" id="importWalletModal" tabindex="-1" aria-labelledby="importWalletModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content" style="background: var(--bg-card); border: 1px solid var(--border-color);">
            <div class="modal-header" style="border-bottom: 1px solid var(--border-color);">
                <h5 class="modal-title" id="importWalletModalLabel">
                    <i class="material-icons align-middle me-2">upload_file</i>
                    Import Wallet
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="filter: invert(1);"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning">
                    <strong>Warning:</strong> Importing a wallet will replace your current wallet and restart the container.
                    Make sure you have backed up your current wallet first!
                </div>

                <div class="mb-3">
                    <label class="form-label">Select Wallet Folder</label>
                    <input type="file"
                           class="form-control"
                           id="walletFolderInputModal"
                           webkitdirectory
                           directory
                           multiple
                           accept=".yaml,.yml">
                    <small class="form-text text-muted">
                        Select the "wallet" folder containing wallet.yaml and vault.yaml
                    </small>
                </div>

                <div id="importFileListModal" class="mb-3" style="display: none;">
                    <label class="form-label">Files to Import:</label>
                    <ul id="importFileListItemsModal" class="small"></ul>
                </div>

                <div id="importResultModal" class="mt-3" style="display: none;"></div>
            </div>
            <div class="modal-footer" style="border-top: 1px solid var(--border-color);">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="importWalletFromModal()" id="importWalletBtnModal" disabled>
                    <i class="material-icons align-middle me-1">upload</i>
                    Import Wallet & Restart
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Stream Onboarding Modal -->
<div class="modal fade" id="streamOnboardingModal" tabindex="-1" aria-labelledby="streamOnboardingModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-lg">
        <div class="modal-content" style="background: var(--bg-card); border: 1px solid var(--border-color);">
            <div class="modal-header" style="border-bottom: 1px solid var(--border-color);">
                <h5 class="modal-title" id="streamOnboardingModalLabel">
                    <i class="material-icons align-middle me-2">play_circle</i>
                    Welcome to Satori - Get Started
                </h5>
            </div>
            <div class="modal-body">
                <p class="mb-3">
                    To start earning rewards, you need to claim streams to predict on.
                    Choose how you'd like to get started:
                </p>

                <!-- Option Tabs -->
                <ul class="nav nav-pills mb-3" id="onboardingTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="auto-pick-tab" data-bs-toggle="pill" data-bs-target="#auto-pick-panel" type="button" role="tab">
                            <i class="material-icons align-middle me-1" style="font-size: 16px;">auto_awesome</i>
                            Auto-Pick
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="manual-pick-tab" data-bs-toggle="pill" data-bs-target="#manual-pick-panel" type="button" role="tab">
                            <i class="material-icons align-middle me-1" style="font-size: 16px;">checklist</i>
                            Manual Select
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="skip-tab" data-bs-toggle="pill" data-bs-target="#skip-panel" type="button" role="tab">
                            <i class="material-icons align-middle me-1" style="font-size: 16px;">skip_next</i>
                            Skip for Now
                        </button>
                    </li>
                </ul>

                <div class="tab-content" id="onboardingTabContent">
                    <!-- Auto-Pick Panel -->
                    <div class="tab-pane fade show active" id="auto-pick-panel" role="tabpanel">
                        <div class="alert alert-info">
                            <i class="material-icons align-middle me-1">info</i>
                            Automatically claim streams with active oracles. The system will select the best streams based on activity and available slots.
                        </div>

                        <h6 class="mb-3">Select Your Load Level:</h6>
                        <div class="row g-3 mb-3">
                            <div class="col-md-4">
                                <div class="card h-100 load-level-card" data-level="light" onclick="selectLoadLevel('light')" style="cursor: pointer; transition: all 0.2s;">
                                    <div class="card-body text-center">
                                        <i class="material-icons" style="font-size: 48px; color: #28a745;">battery_3_bar</i>
                                        <h5 class="mt-2">Light</h5>
                                        <p class="text-muted mb-0">5 streams</p>
                                        <small class="text-muted">Low CPU usage, good for testing</small>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="card h-100 load-level-card selected" data-level="medium" onclick="selectLoadLevel('medium')" style="cursor: pointer; transition: all 0.2s; border: 2px solid var(--accent-color);">
                                    <div class="card-body text-center">
                                        <i class="material-icons" style="font-size: 48px; color: #ffc107;">battery_5_bar</i>
                                        <h5 class="mt-2">Medium</h5>
                                        <span class="badge bg-primary">Recommended</span>
                                        <p class="text-muted mb-0">15 streams</p>
                                        <small class="text-muted">Balanced performance</small>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="card h-100 load-level-card" data-level="heavy" onclick="selectLoadLevel('heavy')" style="cursor: pointer; transition: all 0.2s;">
                                    <div class="card-body text-center">
                                        <i class="material-icons" style="font-size: 48px; color: #dc3545;">battery_full</i>
                                        <h5 class="mt-2">Heavy</h5>
                                        <p class="text-muted mb-0">30 streams</p>
                                        <small class="text-muted">Higher rewards, more resources</small>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="text-center">
                            <button class="btn btn-primary btn-lg" onclick="autoPickStreams()">
                                <i class="material-icons align-middle me-1">auto_awesome</i>
                                Auto-Pick Streams
                            </button>
                        </div>

                        <!-- Auto-pick progress -->
                        <div id="autoPickProgress" class="mt-3" style="display: none;">
                            <div class="progress" style="height: 25px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated" id="autoPickProgressBar" style="width: 0%"></div>
                            </div>
                            <p class="text-center text-muted mt-2" id="autoPickStatus">Finding active streams...</p>
                        </div>

                        <!-- Auto-timeout notice -->
                        <div class="text-center mt-3">
                            <small class="text-muted" id="autoTimeoutNotice">
                                <i class="material-icons align-middle" style="font-size: 14px;">schedule</i>
                                If you don't select within <span id="autoTimeoutCountdown">180</span>s, Medium will be auto-selected
                            </small>
                        </div>
                    </div>

                    <!-- Manual Pick Panel -->
                    <div class="tab-pane fade" id="manual-pick-panel" role="tabpanel">
                        <div class="alert alert-info">
                            <i class="material-icons align-middle me-1">info</i>
                            Manually select which streams to predict on. Only streams with active oracles (published in last 15 minutes) are shown.
                        </div>

                        <div class="mb-3">
                            <div class="input-group">
                                <span class="input-group-text"><i class="material-icons">search</i></span>
                                <input type="text" class="form-control" id="streamSearchInput" placeholder="Search streams..." onkeyup="filterStreamsList()">
                            </div>
                        </div>

                        <div class="mb-2 d-flex justify-content-between align-items-center">
                            <span class="text-muted">
                                <span id="selectedStreamCount">0</span> selected
                            </span>
                            <div>
                                <button class="btn btn-sm btn-outline-secondary" onclick="selectAllStreams()">Select All</button>
                                <button class="btn btn-sm btn-outline-secondary" onclick="deselectAllStreams()">Clear</button>
                            </div>
                        </div>

                        <div id="streamsList" class="list-group mb-3" style="max-height: 300px; overflow-y: auto;">
                            <div class="text-center py-4">
                                <div class="spinner-border spinner-border-sm" role="status"></div>
                                <span class="ms-2">Loading available streams...</span>
                            </div>
                        </div>

                        <div class="text-center">
                            <button class="btn btn-primary btn-lg" onclick="claimSelectedStreams()" id="claimSelectedBtn" disabled>
                                <i class="material-icons align-middle me-1">check_circle</i>
                                Claim Selected Streams
                            </button>
                        </div>
                    </div>

                    <!-- Skip Panel -->
                    <div class="tab-pane fade" id="skip-panel" role="tabpanel">
                        <div class="alert alert-warning">
                            <i class="material-icons align-middle me-1">warning</i>
                            <strong>Note:</strong> Without claimed streams, your node won't make predictions or earn rewards.
                        </div>

                        <p>
                            You can always claim streams later from the Predictions page. Your node will still:
                        </p>
                        <ul>
                            <li>Connect to the P2P network</li>
                            <li>Participate in data relay</li>
                            <li>Sync with other nodes</li>
                        </ul>

                        <div class="text-center">
                            <button class="btn btn-outline-secondary btn-lg" onclick="skipOnboarding()">
                                <i class="material-icons align-middle me-1">skip_next</i>
                                Skip for Now
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="border-top: 1px solid var(--border-color);">
                <small class="text-muted">
                    <i class="material-icons align-middle" style="font-size: 14px;">help_outline</i>
                    You can manage your streams anytime from the Predictions page
                </small>
            </div>
        </div>
    </div>
</div>

<div class="container-fluid py-4">
    <div class="row g-4">
        <!-- Wallet Section -->
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">account_balance_wallet</i>
                        Wallet
                    </h5>
                    <a href="#" class="btn btn-outline-secondary btn-sm" onclick="toggleIdentityWallet(); return false;">
                        <i class="material-icons align-middle" style="font-size: 16px;">badge</i>
                        Identity
                    </a>
                </div>
                <div class="card-body">
                    <div class="row">
                        <!-- Left side: QR Code and Address -->
                        <div class="col-lg-6 mb-4 mb-lg-0">
                            <div class="text-center mb-3">
                                <div id="walletQrCode" class="mb-3" style="display: inline-block; background: white; padding: 10px; border-radius: 10px;">
                                    <p class="text-muted mb-0">Loading QR code...</p>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Wallet Address</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="walletAddress" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('walletAddress')" title="Copy to clipboard">
                                        <i class="material-icons align-middle">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="text-center">
                                <p id="showPrivateKeyBtn" class="text-danger mb-2" style="cursor: pointer;" onclick="togglePrivateKey()">
                                    <i class="material-icons align-middle" style="font-size: 18px;">visibility</i>
                                    Show Private Key
                                </p>
                                <div id="privateKeySection" style="display: none;">
                                    <p class="text-muted mb-2" style="cursor: pointer;" onclick="togglePrivateKey()">
                                        <i class="material-icons align-middle" style="font-size: 18px;">visibility_off</i>
                                        Hide Private Key
                                    </p>
                                    <div class="alert alert-warning" style="word-break: break-all;">
                                        <small><strong>Private Key:</strong></small><br>
                                        <code id="walletPrivateKey">Loading...</code>
                                    </div>
                                    <button class="btn btn-outline-secondary btn-sm" onclick="copyPrivateKey()">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                        Copy Private Key
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Right side: Send Tokens -->
                        <div class="col-lg-6">
                            <h6 class="mb-3">
                                <i class="material-icons align-middle me-1">send</i>
                                Send SATORI
                            </h6>
                            <div class="mb-3">
                                <label class="form-label">Send From</label>
                                <div class="d-flex gap-3">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="sendSource" id="sendFromVault" value="vault" checked>
                                        <label class="form-check-label" for="sendFromVault">
                                            Vault <small class="text-muted" id="vaultBalanceLabel">(--)</small>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="sendSource" id="sendFromWallet" value="wallet">
                                        <label class="form-check-label" for="sendFromWallet">
                                            Identity Wallet <small class="text-muted" id="walletBalanceLabel">(--)</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Destination Address</label>
                                <input type="text" class="form-control" id="sendDestAddress" placeholder="Enter destination address (E...)">
                            </div>
                            <div class="row mb-3">
                                <div class="col-8">
                                    <label class="form-label">Amount</label>
                                    <input type="number" class="form-control" id="sendAmount" placeholder="0.00" step="0.00000001" min="0">
                                </div>
                                <div class="col-4">
                                    <label class="form-label">Sweep All</label>
                                    <div class="form-check mt-2">
                                        <input class="form-check-input" type="checkbox" id="sendSweep" onchange="toggleSweepAmount()">
                                        <label class="form-check-label" for="sendSweep">Send All</label>
                                    </div>
                                </div>
                            </div>
                            <button class="btn btn-primary w-100" onclick="sendTransaction()" id="sendBtn">
                                <i class="material-icons align-middle me-1">send</i>
                                Send Transaction
                            </button>
                            <div id="sendResult" class="mt-3" style="display: none;"></div>
                            <p class="text-muted small mt-3 mb-0">
                                Transaction fees will be paid during the send process. They typically amount to no more than 0.25 EVR.
                            </p>
                        </div>
                    </div>

                    <!-- Identity Wallet (Collapsed) -->
                    <div id="identityWalletSection" style="display: none;" class="mt-4 pt-4 border-top">
                        <h6 class="text-muted mb-3">
                            <i class="material-icons align-middle me-1">badge</i>
                            Identity Wallet (for digital identity only - do not send tokens here)
                        </h6>
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label class="form-label small">Identity Address</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="identityAddress" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('identityAddress')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label small">Identity Private Key</label>
                                <div class="input-group input-group-sm">
                                    <input type="password" class="form-control" id="identityPrivateKey" readonly placeholder="Click to reveal...">
                                    <button class="btn btn-outline-secondary" onclick="toggleIdentityPrivateKey()" title="Show/Hide">
                                        <i class="material-icons align-middle" style="font-size: 16px;" id="identityKeyIcon">visibility</i>
                                    </button>
                                    <button class="btn btn-outline-secondary" onclick="copyIdentityPrivateKey()" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label small">Identity Public Key</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="identityPublicKey" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('identityPublicKey')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label small">Vault Public Key</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="vaultPublicKey" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('vaultPublicKey')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label small">P2P Peer ID</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="p2pPeerId" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('p2pPeerId')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label small">P2P Multiaddress</label>
                                <div class="input-group input-group-sm">
                                    <input type="text" class="form-control" id="p2pMultiaddr" readonly placeholder="Loading...">
                                    <button class="btn btn-outline-secondary" onclick="copyToClipboard('p2pMultiaddr')" title="Copy">
                                        <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Burn Address for Reverse Bridge Section -->
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">local_fire_department</i>
                        Burn Address for Reverse Bridge
                    </h5>
                </div>
                <div class="card-body">
                    <p class="text-muted mb-3">
                        Send SATORI tokens on Base chain to this address to bridge them back to Evrmore
                    </p>
                    <div class="mb-3">
                        <label class="form-label">Base Chain Burn Address</label>
                        <div class="input-group">
                            {% if eth_wallet_address %}
                            <input type="text" class="form-control" id="burnAddress" readonly value="{{ eth_wallet_address }}">
                            <button class="btn btn-outline-secondary" onclick="copyToClipboard('burnAddress')" title="Copy burn address">
                                <i class="material-icons align-middle">content_copy</i>
                            </button>
                            {% else %}
                            <input type="text" class="form-control" readonly value="Not available" disabled>
                            {% endif %}
                        </div>
                        <small class="text-muted">Ethereum address ending in "DEAD"</small>
                    </div>
                    <div class="alert alert-info" role="alert">
                        <strong>How it works:</strong>
                        <ol class="mb-0 mt-2">
                            <li>Send SATORI tokens to this burn address on the <strong>Base blockchain</strong></li>
                            <li>Tokens are tracked by the bridge system daily at 20:00 UTC</li>
                            <li>After 30 days, equivalent SATORI will be minted on Evrmore chain to your wallet</li>
                        </ol>
                    </div>
                    <div class="alert alert-danger" role="alert">
                        <i class="material-icons align-middle me-1" style="font-size: 18px;">warning</i>
                        <strong>Warning:</strong> Only send SATORI tokens from Base chain. Sending other tokens or from wrong networks will result in permanent loss.
                    </div>
                </div>
            </div>
        </div>

        <!-- Balance Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">account_balance_wallet</i>
                        Balance
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="refreshBalance()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="card-body">
                    <div class="row text-center py-3">
                        <div class="col-md-4 col-6 mb-3 mb-md-0">
                            <h3 id="tokenBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">SATORI Token</p>
                            <p id="tokenUsdValue" class="text-muted mb-0" style="font-size: 0.75rem;"></p>
                        </div>
                        <div class="col-md-4 col-6 mb-3 mb-md-0">
                            <h3 id="stakeBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">SATORI Stake</p>
                            <p id="stakeUsdValue" class="text-muted mb-0" style="font-size: 0.75rem;"></p>
                        </div>
                        <div class="col-md-4 col-12">
                            <h3 id="evrBalance">
                                <span class="spinner-border spinner-border-sm" role="status"></span>
                            </h3>
                            <p class="text-muted mb-0">Evrmore (EVR)</p>
                            <p id="evrUsdValue" class="text-muted mb-0" style="font-size: 0.75rem;"></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Reward Address Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">card_giftcard</i>
                        Reward Address
                    </h5>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Current Address</label>
                        <input type="text" class="form-control" id="currentRewardAddress" readonly placeholder="Not set">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">New Address</label>
                        <input type="text" class="form-control" id="newRewardAddress" placeholder="Enter new reward address">
                    </div>
                    <button class="btn btn-primary" onclick="setRewardAddress()">Save Address</button>
                </div>
            </div>
        </div>

        <!-- P2P Network Health Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">hub</i>
                        P2P Network
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="loadP2PHealth()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-4">
                            <div class="text-center">
                                <div class="h4 mb-0" id="p2pPeerCount">--</div>
                                <small class="text-muted">Peers</small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="text-center">
                                <div class="h4 mb-0" id="p2pUptimePct">--%</div>
                                <small class="text-muted">Uptime</small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="text-center">
                                <div class="h4 mb-0" id="p2pStreakDays">--</div>
                                <small class="text-muted">Streak</small>
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Current Round</label>
                        <div class="d-flex justify-content-between align-items-center">
                            <span id="p2pCurrentRound" class="badge bg-primary">--</span>
                            <small class="text-muted" id="p2pRoundStatus">
                                <span id="p2pHeartbeatsSent">--</span> heartbeats sent
                            </small>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Mode</label>
                        <div id="p2pMode" class="alert alert-secondary py-2 mb-0">
                            <span id="p2pModeText">Loading...</span>
                            <span id="p2pRelayBadge" class="badge bg-success ms-2" style="display: none;">Relay Eligible</span>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Recent Heartbeats</label>
                        <div id="heartbeatFeed" class="list-group" style="max-height: 120px; overflow-y: auto; font-size: 0.85em;">
                            <div class="text-muted small p-2">Loading heartbeats...</div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">My Delegation</label>
                        <div id="delegationInfo" class="small">
                            <p class="text-muted mb-1">Not delegating to anyone</p>
                        </div>
                    </div>
                    <div>
                        <label class="form-label">Proxy Children</label>
                        <div id="proxyChildren" class="small">
                            <p class="text-muted mb-0">No children delegating to me</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Treasury Alerts Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100" id="treasuryAlertsCard">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2" id="treasuryAlertIcon">notifications</i>
                        <span id="treasuryAlertTitle">Treasury Status</span>
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="loadTreasuryAlerts()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="card-body">
                    <!-- Alert Banner -->
                    <div id="activeAlertBanner" class="alert alert-warning mb-3" style="display: none;">
                        <div class="d-flex align-items-start">
                            <i class="material-icons me-2" id="alertBannerIcon">warning</i>
                            <div class="flex-grow-1">
                                <strong id="alertBannerTitle">Treasury Alert</strong>
                                <p class="mb-2 small" id="alertBannerMessage">Alert message here</p>
                                <div id="alertActionButtons" class="d-flex gap-2 flex-wrap"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Treasury Status -->
                    <div class="row text-center mb-3">
                        <div class="col-6">
                            <div class="h5 mb-0" id="treasurySatoriLevel">--</div>
                            <small class="text-muted">SATORI Level</small>
                        </div>
                        <div class="col-6">
                            <div class="h5 mb-0" id="treasuryEvrLevel">--</div>
                            <small class="text-muted">EVR Level</small>
                        </div>
                    </div>

                    <!-- Deferred Rewards Section -->
                    <div id="deferredRewardsSection" style="display: none;">
                        <hr>
                        <label class="form-label">
                            <i class="material-icons align-middle me-1" style="font-size: 16px;">schedule</i>
                            Your Deferred Rewards
                        </label>
                        <div class="alert alert-info py-2 mb-2">
                            <div class="d-flex justify-content-between">
                                <span>Total Pending:</span>
                                <strong id="deferredTotal">0 SATORI</strong>
                            </div>
                            <div class="d-flex justify-content-between">
                                <span>Deferred Rounds:</span>
                                <strong id="deferredCount">0</strong>
                            </div>
                        </div>
                        <small class="text-muted">
                            These rewards will be paid automatically when the treasury is funded.
                        </small>
                    </div>

                    <!-- Alert History -->
                    <div class="mt-3">
                        <a href="#" class="small text-muted" onclick="toggleAlertHistory(); return false;">
                            <i class="material-icons align-middle" style="font-size: 14px;">history</i>
                            View Alert History
                        </a>
                        <div id="alertHistoryList" class="mt-2" style="display: none; max-height: 150px; overflow-y: auto;">
                            <div class="text-muted small">Loading...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- My Rewards History Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#rewardsHistoryCollapse"
                     aria-expanded="true"
                     aria-controls="rewardsHistoryCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">payments</i>
                        My Rewards History
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadMyRewardsHistory()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="collapse show" id="rewardsHistoryCollapse">
                <div class="card-body">
                    <!-- Rewards Summary -->
                    <div class="row text-center mb-3">
                        <div class="col-4">
                            <div class="h5 mb-0 text-success" id="rewardsTotalEarned">--</div>
                            <small class="text-muted">Total Earned</small>
                        </div>
                        <div class="col-4">
                            <div class="h5 mb-0 text-primary" id="rewardsThisMonth">--</div>
                            <small class="text-muted">This Month</small>
                        </div>
                        <div class="col-4">
                            <div class="h5 mb-0 text-info" id="rewardsDistCount">--</div>
                            <small class="text-muted">Distributions</small>
                        </div>
                    </div>

                    <!-- Rewards List -->
                    <div id="rewardsHistoryList" class="list-group list-group-flush" style="max-height: 200px; overflow-y: auto;">
                        <div class="text-muted small text-center py-3">Loading rewards history...</div>
                    </div>

                    <!-- View More Link -->
                    <div class="text-center mt-2">
                        <a href="{{ url_for('network') }}" class="small text-muted">
                            <i class="material-icons align-middle" style="font-size: 14px;">open_in_new</i>
                            View Full Distribution History on Network Page
                        </a>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Prediction Stats Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#predictionStatsCollapse"
                     aria-expanded="true"
                     aria-controls="predictionStatsCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">analytics</i>
                        Prediction Stats
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadPredictionStats()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="collapse show" id="predictionStatsCollapse">
                <div class="card-body">
                    <!-- Prediction Summary -->
                    <div class="row text-center mb-3">
                        <div class="col-4">
                            <div class="h5 mb-0 text-primary" id="predictionCount">--</div>
                            <small class="text-muted">Predictions</small>
                        </div>
                        <div class="col-4">
                            <div class="h5 mb-0 text-success" id="predictionAccuracy">--%</div>
                            <small class="text-muted">Accuracy</small>
                        </div>
                        <div class="col-4">
                            <div class="h5 mb-0 text-info" id="predictionStreams">--</div>
                            <small class="text-muted">Streams</small>
                        </div>
                    </div>

                    <!-- Status -->
                    <div class="mb-3">
                        <label class="form-label">Status</label>
                        <div id="predictionStatus" class="alert alert-secondary py-2 mb-0">
                            <span id="predictionStatusText">Loading...</span>
                        </div>
                    </div>

                    <!-- Recent Activity -->
                    <div class="mb-3">
                        <label class="form-label">Recent Scores</label>
                        <div id="recentScoresList" class="list-group list-group-flush" style="max-height: 120px; overflow-y: auto; font-size: 0.85em;">
                            <div class="text-muted small p-2">Loading scores...</div>
                        </div>
                    </div>

                    <!-- View More Link -->
                    <div class="text-center mt-2">
                        <a href="{{ url_for('predictions_page') }}" class="small text-muted">
                            <i class="material-icons align-middle" style="font-size: 14px;">open_in_new</i>
                            View Full Predictions Page
                        </a>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- My Claimed Streams Row -->
    <div class="row g-4 mt-2">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#myClaimsCollapse"
                     aria-expanded="false"
                     aria-controls="myClaimsCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">playlist_add_check</i>
                        My Claimed Streams
                        <span class="badge bg-primary ms-2" id="claimedStreamsCount">0</span>
                    </h5>
                    <div>
                        <button class="btn btn-sm btn-outline-success me-2" onclick="event.stopPropagation(); renewAllClaims()" title="Renew All Claims">
                            <i class="material-icons align-middle" style="font-size: 16px;">autorenew</i>
                            Renew All
                        </button>
                        <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadMyClaims()">
                            <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                        </button>
                    </div>
                </div>
                <div class="collapse" id="myClaimsCollapse">
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-hover mb-0">
                                <thead>
                                    <tr>
                                        <th>Stream</th>
                                        <th>Slot</th>
                                        <th>Claimed</th>
                                        <th>Expires</th>
                                        <th>Status</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="myClaimsTable">
                                    <tr><td colspan="6" class="text-center text-muted py-3">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pool Staking Row -->
    <div class="row g-4 mt-2">
        <!-- Pool Staking Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#poolStakingCollapse"
                     aria-expanded="false"
                     aria-controls="poolStakingCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">handshake</i>
                        Pool Staking
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadAvailablePools()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="collapse" id="poolStakingCollapse">
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Status</label>
                        <div id="stakingStatus" class="alert alert-secondary">Not staking with a pool</div>
                    </div>

                    <!-- Available Pools List -->
                    <div class="mb-3">
                        <label class="form-label">Available Open Pools</label>
                        <div id="availablePoolsList" class="list-group mb-2" style="max-height: 200px; overflow-y: auto;">
                            <div class="text-muted small p-2">Loading pools...</div>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Pool Address</label>
                        <span class="d-inline-block w-100" id="poolAddressWrapper" data-bs-toggle="tooltip" data-bs-placement="top" title="">
                            <input type="text" class="form-control" id="poolAddress" placeholder="Enter pool address or select from list above">
                        </span>
                    </div>
                    <div class="d-flex gap-2">
                        <span class="d-inline-block" id="addStakeBtnWrapper" data-bs-toggle="tooltip" data-bs-placement="top" title="">
                            <button class="btn btn-primary" id="addStakeBtn" onclick="addStakeToPool()">Add Stake to Pool</button>
                        </span>
                        <span class="d-inline-block" id="removeStakeBtnWrapper" data-bs-toggle="tooltip" data-bs-placement="top" title="">
                            <button class="btn btn-danger" id="removeStakeBtn" onclick="removeStakeFromPool()">Remove Stake from Pool</button>
                        </span>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Pool Management Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#poolManagementCollapse"
                     aria-expanded="false"
                     aria-controls="poolManagementCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">groups</i>
                        Pool Management
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadWorkers(); loadLenders();">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="collapse" id="poolManagementCollapse">
                <div class="card-body" id="poolManagementBody">
                    <!-- Pool Staking Notice (shown when user is staking to another pool) -->
                    <div class="alert alert-warning pool-staking-notice mb-3" id="poolStakingNotice" style="display: none;">
                        <i class="material-icons align-middle me-1" style="font-size: 18px;">info</i>
                        <strong>Note:</strong> Staking to a pool disables this neuron to act as a pool.
                    </div>

                    <div class="mb-3">
                        <label class="form-label">Lender Commission (%)</label>
                        <span class="d-inline-block w-100" id="poolCommissionWrapper" data-bs-toggle="tooltip" data-bs-placement="top" title="">
                            <div class="input-group">
                                <input type="number" class="form-control" id="poolCommission"
                                       placeholder="0 = closed, 1-100 = open"
                                       min="0" max="100" step="1"
                                       onchange="setPoolCommission()"
                                       onkeypress="if(event.key === 'Enter') { setPoolCommission(); event.preventDefault(); }">
                                <span class="input-group-text">%</span>
                            </div>
                        </span>
                        <small class="form-text text-muted">
                            Commission you pay to pool stakers. Empty or 0 = pool closed. 1-100 = pool open.
                        </small>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Workers</label>
                        <div id="workerList" class="mb-2" style="max-height: 150px; overflow-y: auto;">
                            <p class="text-muted">Loading...</p>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Add Worker</label>
                        <span class="d-inline-block w-100" id="addWorkerWrapper" data-bs-toggle="tooltip" data-bs-placement="top" title="">
                            <div class="input-group">
                                <input type="text" class="form-control" id="newWorkerAddress" placeholder="Worker address">
                                <button class="btn btn-primary" id="addWorkerBtn" onclick="addWorker()">Add</button>
                            </div>
                        </span>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Pool Stakers</label>
                        <div id="lenderList" class="mb-2" style="max-height: 150px; overflow-y: auto;">
                            <p class="text-muted">Loading...</p>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Donate & Referral Row -->
    <div class="row g-4 mt-2">
        <!-- Donate Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#donateCollapse"
                     aria-expanded="false"
                     aria-controls="donateCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">volunteer_activism</i>
                        Donate to Treasury
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadDonationStats()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="collapse" id="donateCollapse">
                <div class="card-body">
                    <!-- Treasury Address -->
                    <div class="mb-3">
                        <label class="form-label">Treasury Address</label>
                        <div class="input-group input-group-sm">
                            <input type="text" class="form-control" id="treasuryAddress" readonly placeholder="Loading...">
                            <button class="btn btn-outline-secondary" onclick="copyToClipboard('treasuryAddress')" title="Copy">
                                <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                            </button>
                        </div>
                        <small class="text-muted">Send EVR to this address to receive SATORI rewards</small>
                    </div>

                    <!-- Donation Form -->
                    <div class="mb-3">
                        <label class="form-label">Donation Amount (EVR)</label>
                        <div class="input-group">
                            <input type="number" class="form-control" id="donationAmount" placeholder="100" min="1" step="1" onchange="updateDonationEstimate()">
                            <span class="input-group-text">EVR</span>
                        </div>
                        <small class="text-muted" id="donationEstimate"> 0 SATORI reward</small>
                    </div>
                    <button class="btn btn-primary w-100" onclick="sendDonation()" id="donateBtn">
                        <i class="material-icons align-middle me-1">send</i>
                        Send Donation
                    </button>
                    <div id="donationResult" class="mt-2" style="display: none;"></div>

                    <hr class="my-3">

                    <!-- My Stats -->
                    <div class="row text-center mb-3">
                        <div class="col-4">
                            <h5 id="donorTotalDonated" class="mb-0">--</h5>
                            <small class="text-muted">Total Donated</small>
                        </div>
                        <div class="col-4">
                            <h5 id="donorTier" class="mb-0">--</h5>
                            <small class="text-muted">Tier</small>
                        </div>
                        <div class="col-4">
                            <h5 id="donorRewardsReceived" class="mb-0">--</h5>
                            <small class="text-muted">Rewards</small>
                        </div>
                    </div>

                    <!-- Tier Progress -->
                    <div class="mb-3">
                        <label class="form-label small">Progress to Next Tier</label>
                        <div class="progress" style="height: 10px;">
                            <div class="progress-bar bg-success" role="progressbar" id="tierProgressBar" style="width: 0%"></div>
                        </div>
                        <small class="text-muted" id="tierProgressText">-- EVR to next tier</small>
                    </div>

                    <!-- Top Donors Button -->
                    <button class="btn btn-outline-secondary btn-sm w-100" onclick="toggleTopDonors()">
                        <i class="material-icons align-middle" style="font-size: 16px;">leaderboard</i>
                        View Top Donors
                    </button>
                    <div id="topDonorsList" class="mt-2" style="display: none;">
                        <div class="text-muted small">Loading...</div>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Referral Section -->
        <div class="col-12 col-lg-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#referralCollapse"
                     aria-expanded="false"
                     aria-controls="referralCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">share</i>
                        Referral Program
                    </h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="event.stopPropagation(); loadReferralStats()">
                        <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                    </button>
                </div>
                <div class="collapse" id="referralCollapse">
                <div class="card-body">
                    <!-- My Stats -->
                    <div class="row text-center mb-3">
                        <div class="col-4">
                            <h4 id="referralCount" class="mb-0">0</h4>
                            <small class="text-muted">Referrals</small>
                        </div>
                        <div class="col-4">
                            <h5 id="referralTier" class="mb-0" style="color: #9e9e9e;">None</h5>
                            <small class="text-muted">Tier</small>
                        </div>
                        <div class="col-4">
                            <h5 id="referralBonus" class="mb-0" style="color: #4CAF50;">+0%</h5>
                            <small class="text-muted">Bonus</small>
                        </div>
                    </div>

                    <!-- Tier Progress -->
                    <div class="mb-3">
                        <label class="form-label small">Progress to Next Tier</label>
                        <div class="progress" style="height: 10px;">
                            <div class="progress-bar bg-primary" role="progressbar" id="referralTierProgressBar" style="width: 0%"></div>
                        </div>
                        <small class="text-muted" id="referralNextTier">5 referrals to Bronze</small>
                    </div>

                    <!-- Share Link -->
                    <div class="mb-3">
                        <label class="form-label">Your Referral Link</label>
                        <div class="input-group input-group-sm">
                            <input type="text" class="form-control" id="referralLink" readonly placeholder="Loading...">
                            <button class="btn btn-outline-secondary" onclick="copyToClipboard('referralLink')" title="Copy">
                                <i class="material-icons align-middle" style="font-size: 16px;">content_copy</i>
                            </button>
                        </div>
                    </div>

                    <!-- Set Referrer -->
                    <div class="mb-3">
                        <label class="form-label">Who referred you?</label>
                        <div class="input-group input-group-sm">
                            <input type="text" class="form-control" id="referrerAddress" placeholder="Enter referrer address">
                            <button class="btn btn-primary btn-sm" onclick="setReferrer()">Set</button>
                        </div>
                    </div>

                    <!-- Top Referrers Button -->
                    <button class="btn btn-outline-secondary btn-sm w-100" onclick="toggleTopReferrers()">
                        <i class="material-icons align-middle" style="font-size: 16px;">leaderboard</i>
                        View Top Referrers
                    </button>
                    <div id="topReferrersList" class="mt-2" style="display: none;">
                        <div class="text-muted small">Loading...</div>
                    </div>

                    <!-- Tier Info -->
                    <div class="mt-3">
                        <small class="text-muted">
                            Tier bonuses: Bronze (5) +2% | Silver (25) +5% | Gold (100) +8% | Platinum (500) +12% | Diamond (2000) +15%
                        </small>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Engine Training Control Section -->
    <div class="row g-4 mt-2">
        <div class="col-12">
            <div class="card">
                <div class="card-header"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#aiEngineCollapse"
                     aria-expanded="false"
                     aria-controls="aiEngineCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">psychology</i>
                        AI Engine Training Frequency
                    </h5>
                </div>
                <div class="collapse" id="aiEngineCollapse">
                <div class="card-body">
                    <div class="mb-3">
                        <label class="form-label">Training Frequency</label>
                        <div class="d-flex align-items-center gap-3">
                            <span class="text-muted small">Slow</span>
                            <input type="range" class="form-range flex-grow-1"
                                   id="trainingDelaySlider"
                                   min="0" max="100" step="1" value="50"
                                   oninput="updateTrainingDelayLabel(this.value)"
                                   onchange="setTrainingDelay(this.value)">
                            <span class="text-muted small">Fast</span>
                        </div>
                        <div class="text-center mt-2">
                            <span class="badge bg-secondary" id="trainingDelayLabel">10 minutes</span>
                        </div>
                        <small class="form-text text-muted">
                            Controls how frequently the AI engine trains new models.
                            Lower frequency = less CPU usage. Higher frequency = faster model improvements.
                        </small>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Engine Performance Dashboard -->
    <div class="row g-4 mt-2">
        <div class="col-12">
            <div class="card">
                <div class="card-header"
                     style="cursor: pointer;"
                     data-bs-toggle="collapse"
                     data-bs-target="#performanceCollapse"
                     aria-expanded="false"
                     aria-controls="performanceCollapse">
                    <h5 class="mb-0">
                        <i class="material-icons align-middle me-2">show_chart</i>
                        AI Engine Performance
                    </h5>
                </div>
                <div class="collapse" id="performanceCollapse">
                <div class="card-body">
                    <!-- Stats Summary -->
                    <div class="row mb-4" id="performanceStats">
                        <div class="col-md-4">
                            <div class="text-center p-3 bg-secondary bg-opacity-10 rounded">
                                <div class="text-muted small">Accuracy</div>
                                <div class="h4 mb-0" id="accuracyPct">--</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="text-center p-3 bg-secondary bg-opacity-10 rounded">
                                <div class="text-muted small">Avg Error</div>
                                <div class="h5 mb-0" id="avgError">--</div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="text-center p-3 bg-secondary bg-opacity-10 rounded">
                                <div class="text-muted small">Avg Abs Error</div>
                                <div class="h5 mb-0" id="avgAbsError">--</div>
                            </div>
                        </div>
                    </div>

                    <!-- Predictions vs Observations Chart -->
                    <div class="mb-4">
                        <h6 class="mb-3">Predictions vs Observations</h6>
                        <div style="position: relative; height: 300px;">
                            <canvas id="predVsObsChart"></canvas>
                        </div>
                        <small class="text-muted">Last 100 data points</small>
                    </div>

                    <!-- Accuracy Over Time Chart -->
                    <div class="mb-3">
                        <h6 class="mb-3">Prediction Accuracy Over Time</h6>
                        <div style="position: relative; height: 300px;">
                            <canvas id="accuracyChart"></canvas>
                        </div>
                        <small class="text-muted">Absolute error between prediction and next observation</small>
                    </div>

                    <div class="text-center mt-3">
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshPerformance()">
                            <i class="material-icons align-middle" style="font-size: 16px;">refresh</i>
                            Refresh Data
                        </button>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Disclaimer Footer -->
<div class="container-fluid py-3">
    <div class="card">
        <div class="card-header text-center"
             style="cursor: pointer;"
             data-bs-toggle="collapse"
             data-bs-target="#disclaimerCollapse"
             aria-expanded="false"
             aria-controls="disclaimerCollapse">
            <h6 class="mb-0 text-muted">
                <i class="material-icons align-middle me-2" style="font-size: 18px;">info</i>
                Disclaimer of Warranties and Limitation of Liability
            </h6>
        </div>
        <div class="collapse" id="disclaimerCollapse">
            <div class="card-body">
                <div class="disclaimer-content" style="font-size: 0.85rem; line-height: 1.6;">
                    <h6>1. DISCLAIMER OF WARRANTIES</h6>
                    <p><strong>AS IS:</strong> The Satori Neuron software ("Software") is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, whether express or implied, including but not limited to implied warranties of merchantability, fitness for a particular purpose, title, and non-infringement.</p>
                    <p><strong>NO GUARANTEE:</strong> We do not guarantee that the Software will be uninterrupted, error-free, secure, or free of viruses or other harmful components.</p>
                    <p><strong>USER RESPONSIBILITY:</strong> The user is solely responsible for any damage to their device or loss of data that results from the use of the Software.</p>

                    <h6 class="mt-3">2. LIMITATION OF LIABILITY</h6>
                    <p><strong>NO LIABILITY FOR DAMAGES:</strong> In no event shall The Satori Association or its affiliates, officers, directors, employees, agents, or licensors be liable for any indirect, incidental, special, consequential, or punitive damages, or any loss of profits or revenues, whether incurred directly or indirectly, or any loss of data, use, goodwill, or other intangible losses, resulting from:</p>
                    <ul>
                        <li>Your use or inability to use the Software;</li>
                        <li>Any unauthorized access to or use of the Software;</li>
                        <li>Any interruption or cessation of transmission to or from the Software;</li>
                        <li>Any bugs, viruses, trojan horses, or the like that may be transmitted to or through the Software by any third party;</li>
                        <li>Any errors or omissions in any content or for any loss or damage incurred as a result of the use of any content posted, emailed, transmitted, or otherwise made available through the Software, whether based on warranty, contract, tort (including negligence), or any other legal theory, whether or not we have been informed of the possibility of such damage.</li>
                    </ul>

                    <h6 class="mt-3">3. MAXIMUM LIABILITY</h6>
                    <p><strong>LIMITATION CAP:</strong> Our maximum aggregate liability under or in connection with the Software, whether in contract, tort (including negligence), or otherwise, shall in no circumstances exceed the amount paid by you, if any, for accessing or using the Software.</p>

                    <h6 class="mt-3">4. EXCLUSIONS</h6>
                    <p><strong>APPLICABLE LAW:</strong> Some jurisdictions do not allow the exclusion of certain warranties or the limitation or exclusion of liability for incidental or consequential damages. Accordingly, some of the above limitations may not apply to you. In such jurisdictions, our liability will be limited to the fullest extent permitted by applicable law.</p>

                    <h6 class="mt-3">5. INDEMNIFICATION</h6>
                    <p><strong>USER INDEMNITY:</strong> You agree to indemnify, defend, and hold harmless The Satori Association and its affiliates, officers, directors, employees, agents, and licensors from and against any claims, liabilities, damages, losses, and expenses, including, without limitation, reasonable legal and accounting fees, arising out of or in any way connected with your access to or use of the Software, or your violation of these terms.</p>

                    <h6 class="mt-3">6. GOVERNING LAW</h6>
                    <p><strong>SWISS LAW:</strong> This Disclaimer of Warranties and Limitation of Liability shall be governed by and construed in accordance with the laws of Switzerland, without regard to its conflict of laws principles.</p>

                    <h6 class="mt-3">7. DISPUTE RESOLUTION</h6>
                    <p><strong>MEDIATION FIRST:</strong> Any disputes arising under or in connection with this Disclaimer of Warranties and Limitation of Liability shall first be attempted to be resolved through mediation. The parties agree to submit the dispute to a mutually agreed-upon mediator in Switzerland. If mediation fails to resolve the dispute, it shall then be resolved in the courts of Switzerland.</p>

                    <h6 class="mt-3">8. CONTACT INFORMATION</h6>
                    <p>For any inquiries regarding this Disclaimer of Warranties and Limitation of Liability, please contact:</p>
                    <p class="mb-0">
                        <strong>The Satori Association</strong><br>
                        <a href="mailto:disclaimer@satorinet.io">disclaimer@satorinet.io</a>
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Messages -->
<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="statusToast" class="toast" role="alert">
        <div class="toast-header bg-dark text-white">
            <strong class="me-auto">Satori</strong>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body" id="toastMessage"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const API_URL = '/api';

    // Helper function to format balance values (removes trailing zeros)
    function formatBalance(value) {
        if (value === undefined || value === null) return '--';
        // Format to 8 decimals then parse to remove trailing zeros
        return parseFloat(parseFloat(value).toFixed(8)).toString();
    }

    // Get color for commission percentage (light green at 0% to red at 100%)
    function getCommissionColor(percentage) {
        // Clamp percentage between 0 and 100
        const p = Math.max(0, Math.min(100, percentage));

        // Light green (144, 238, 144) at 0% to red (220, 53, 69) at 100%
        const r = Math.round(144 + (220 - 144) * (p / 100));
        const g = Math.round(238 + (53 - 238) * (p / 100));
        const b = Math.round(144 + (69 - 144) * (p / 100));

        return `rgb(${r}, ${g}, ${b})`;
    }

    // State tracking for mutual exclusion
    let isStakingToPool = false;
    let isOpenPool = false;  // True if pool has commission > 0 (accepting pool stakers)
    let hasWorkers = false;  // True if user has workers (active pool)

    function showToast(message, isError = false) {
        const toast = document.getElementById('statusToast');
        const toastBody = document.getElementById('toastMessage');
        toastBody.textContent = message;
        toastBody.className = 'toast-body ' + (isError ? 'text-danger' : 'text-success');
        const bsToast = new bootstrap.Toast(toast);
        bsToast.show();
    }

    async function apiCall(endpoint, method = 'GET', data = null) {
        let isNetworkError = false;
        try {
            const options = {
                method: method,
                headers: {
                    'Content-Type': 'application/json'
                }
            };
            if (data) {
                options.body = JSON.stringify(data);
            }
            const response = await fetch(API_URL + endpoint, options);

            // If we got a response, server is reachable - update status to connected
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (indicator && text) {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
            }

            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                const text = await response.text();
                throw new Error(`Server returned non-JSON response: ${text.substring(0, 100)}`);
            }

            const result = await response.json();

            // Check for HTTP errors (but server is still connected)
            if (!response.ok) {
                // Handle error properly - could be string or object
                let errorMsg = `HTTP ${response.status}`;
                if (result.detail) {
                    errorMsg = typeof result.detail === 'object' ? JSON.stringify(result.detail) : result.detail;
                } else if (result.error) {
                    errorMsg = typeof result.error === 'object' ? JSON.stringify(result.error) : result.error;
                }
                throw new Error(errorMsg);
            }

            return result;
        } catch (error) {
            console.error('API Error:', error);

            // Only show "Disconnected" for network errors (not HTTP errors like 404, 401)
            // Network errors: TypeError (failed to fetch), timeout, connection refused
            if (error instanceof TypeError || error.message.includes('fetch') || error.message.includes('network')) {
                isNetworkError = true;
                const indicator = document.getElementById('statusIndicator');
                const text = document.getElementById('statusText');
                if (indicator && text) {
                    indicator.className = 'status-indicator status-offline';
                    text.textContent = 'Disconnected';
                }
            }

            // Ensure error message is always a string
            const errorMsg = error.message || String(error);
            showToast('API Error: ' + errorMsg, true);
            return null;
        }
    }

    // =========================================================================
    // P2P NETWORK HEALTH FUNCTIONS
    // =========================================================================

    async function loadP2PHealth() {
        try {
            // Load basic health stats
            const health = await apiCall('/p2p/health');
            if (health) {
                document.getElementById('p2pPeerCount').textContent = health.peer_count || 0;
                document.getElementById('p2pUptimePct').textContent =
                    (health.uptime_pct ? (health.uptime_pct * 100).toFixed(1) : '0') + '%';

                const modeText = document.getElementById('p2pModeText');
                const modeAlert = document.getElementById('p2pMode');
                const relayBadge = document.getElementById('p2pRelayBadge');

                modeText.textContent = health.mode.toUpperCase();

                if (health.connected) {
                    modeAlert.className = 'alert alert-success py-2 mb-0';
                } else if (health.mode === 'central') {
                    modeAlert.className = 'alert alert-secondary py-2 mb-0';
                } else {
                    modeAlert.className = 'alert alert-warning py-2 mb-0';
                }

                relayBadge.style.display = health.relay_eligible ? 'inline' : 'none';
            }

            // Load round stats from heartbeat stats endpoint
            const hbStats = await apiCall('/p2p/heartbeat/stats');
            if (hbStats) {
                // Current round display (e.g., "round_2026-01-19" -> "2026-01-19")
                const roundDisplay = hbStats.current_round ?
                    hbStats.current_round.replace('round_', '') : '--';
                document.getElementById('p2pCurrentRound').textContent = roundDisplay;

                // Heartbeats sent this round
                document.getElementById('p2pHeartbeatsSent').textContent =
                    hbStats.heartbeats_sent || 0;

                // Streak days
                document.getElementById('p2pStreakDays').textContent =
                    hbStats.streak_days ? hbStats.streak_days + 'd' : '0d';
            }
        } catch (e) {
            console.error('Failed to load P2P health:', e);
        }
    }

    async function loadHeartbeats() {
        try {
            const data = await apiCall('/p2p/heartbeats?limit=10');
            const feed = document.getElementById('heartbeatFeed');

            if (data && data.heartbeats && data.heartbeats.length > 0) {
                feed.innerHTML = data.heartbeats.map(hb => {
                    const ago = Math.floor((Date.now()/1000) - hb.timestamp);
                    const roles = hb.roles ? hb.roles.join(', ') : '';
                    return `<div class="list-group-item py-1 px-2">
                        <span class="text-success"></span>
                        <span class="text-muted">${hb.address}</span>
                        <span class="badge bg-secondary ms-1">${roles || 'predictor'}</span>
                        <small class="text-muted float-end">${ago}s ago</small>
                    </div>`;
                }).join('');
            } else {
                feed.innerHTML = '<div class="text-muted small p-2">No heartbeats yet</div>';
            }
        } catch (e) {
            console.error('Failed to load heartbeats:', e);
        }
    }

    async function loadDelegations() {
        try {
            const data = await apiCall('/p2p/delegations');

            // My delegation
            const delegationInfo = document.getElementById('delegationInfo');
            if (data && data.my_delegate) {
                const d = data.my_delegate;
                delegationInfo.innerHTML = `
                    <p class="mb-1">Delegating to: <code>${d.parent_address}</code></p>
                    <p class="mb-0">Amount: ${d.amount} ${d.charity ? '<span class="badge bg-info">Charity</span>' : ''}</p>
                `;
            } else {
                delegationInfo.innerHTML = '<p class="text-muted mb-0">Not delegating to anyone</p>';
            }

            // Proxy children
            const proxyChildren = document.getElementById('proxyChildren');
            if (data && data.my_children && data.my_children.length > 0) {
                proxyChildren.innerHTML = data.my_children.map(c => `
                    <div class="mb-1">
                        <code>${c.child_address}</code>: ${c.amount}
                        ${c.charity ? '<span class="badge bg-info">Charity</span>' : ''}
                    </div>
                `).join('');
            } else {
                proxyChildren.innerHTML = '<p class="text-muted mb-0">No children delegating to me</p>';
            }
        } catch (e) {
            console.error('Failed to load delegations:', e);
        }
    }

    // Load all P2P data
    async function loadAllP2PData() {
        await Promise.all([
            loadP2PHealth(),
            loadHeartbeats(),
            loadDelegations()
        ]);
    }

    // =========================================================================
    // MUTUAL EXCLUSION FUNCTIONS
    // =========================================================================

    // Update UI based on mutual exclusion rules
    function updateMutualExclusionUI() {
        // Pool Staking elements
        const poolAddressInput = document.getElementById('poolAddress');
        const poolAddressWrapper = document.getElementById('poolAddressWrapper');
        const addStakeBtn = document.getElementById('addStakeBtn');
        const addStakeBtnWrapper = document.getElementById('addStakeBtnWrapper');
        const removeStakeBtn = document.getElementById('removeStakeBtn');
        const removeStakeBtnWrapper = document.getElementById('removeStakeBtnWrapper');

        // Pool Staking inputs are always enabled
        if (poolAddressInput) poolAddressInput.disabled = false;
        if (poolAddressWrapper) poolAddressWrapper.setAttribute('title', '');
        if (addStakeBtn) addStakeBtn.disabled = false;
        if (addStakeBtnWrapper) addStakeBtnWrapper.setAttribute('title', '');

        // Remove button only enabled if actually staking to a pool
        if (isStakingToPool) {
            if (removeStakeBtn) removeStakeBtn.disabled = false;
            if (removeStakeBtnWrapper) removeStakeBtnWrapper.setAttribute('title', '');
        } else {
            if (removeStakeBtn) removeStakeBtn.disabled = true;
            if (removeStakeBtnWrapper) removeStakeBtnWrapper.setAttribute('title', 'You are not currently staking to a pool');
        }

        // If staking to pool, dim Pool Management card and show notice
        const poolManagementBody = document.getElementById('poolManagementBody');
        const poolStakingNotice = document.getElementById('poolStakingNotice');

        if (isStakingToPool) {
            if (poolManagementBody) poolManagementBody.classList.add('dimmed');
            if (poolStakingNotice) poolStakingNotice.style.display = 'block';
        } else {
            if (poolManagementBody) poolManagementBody.classList.remove('dimmed');
            if (poolStakingNotice) poolStakingNotice.style.display = 'none';
        }

        // Update card collapse states based on usage
        updateCardCollapseStates();
    }

    function updateCardCollapseStates() {
        const poolStakingCollapse = document.getElementById('poolStakingCollapse');
        const poolManagementCollapse = document.getElementById('poolManagementCollapse');

        if (poolStakingCollapse) {
            // Show Pool Staking card if user is staking to a pool
            if (isStakingToPool) {
                poolStakingCollapse.classList.add('show');
            } else {
                poolStakingCollapse.classList.remove('show');
            }
        }

        if (poolManagementCollapse) {
            // Show Pool Management card if user is an open pool or has workers
            if (isOpenPool || hasWorkers) {
                poolManagementCollapse.classList.add('show');
            } else {
                poolManagementCollapse.classList.remove('show');
            }
        }
    }

    function setBalanceLoading(elementId, isLoading) {
        const element = document.getElementById(elementId);
        if (isLoading) {
            element.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span>';
        }
    }

    async function loadBalance() {
        // Load stake from Satori API server (only source for stake info)
        try {
            const result = await apiCall('/balance/get');
            if (result && result.stake !== undefined) {
                document.getElementById('stakeBalance').textContent = result.stake;
            } else {
                document.getElementById('stakeBalance').textContent = '--';
            }
        } catch (error) {
            console.error('Failed to load stake balance:', error);
            document.getElementById('stakeBalance').textContent = '--';
        }
    }

    async function refreshBalance() {
        // Get real-time balance from electrumx blockchain (wallet + vault)
        // Fetches SATORI token and EVR balance
        setBalanceLoading('tokenBalance', true);
        setBalanceLoading('evrBalance', true);

        try {
            const result = await apiCall('/wallet/balance/direct');
            if (result && !result.error) {
                document.getElementById('tokenBalance').textContent = result.total !== undefined ? formatBalance(result.total) : '--';
                document.getElementById('evrBalance').textContent = result.total_evr !== undefined ? formatBalance(result.total_evr) : '--';

                // Update balance labels in send section
                if (result.vault_balance !== undefined) {
                    document.getElementById('vaultBalanceLabel').textContent = '(' + formatBalance(result.vault_balance) + ')';
                }
                if (result.wallet_balance !== undefined) {
                    document.getElementById('walletBalanceLabel').textContent = '(' + formatBalance(result.wallet_balance) + ')';
                }

                // Load USD values for balances
                loadUsdValues(result.total || 0, result.total_evr || 0);
            } else {
                // If there's an error, show dashes
                document.getElementById('tokenBalance').textContent = '--';
                document.getElementById('evrBalance').textContent = '--';
                document.getElementById('vaultBalanceLabel').textContent = '(--)';
                document.getElementById('walletBalanceLabel').textContent = '(--)';
                if (result && result.error) {
                    console.error('ElectrumX balance fetch error:', result.error);
                }
            }
        } catch (error) {
            console.error('Failed to fetch balance from ElectrumX:', error);
            document.getElementById('tokenBalance').textContent = '--';
            document.getElementById('evrBalance').textContent = '--';
            document.getElementById('vaultBalanceLabel').textContent = '(--)';
            document.getElementById('walletBalanceLabel').textContent = '(--)';
        }
    }

    async function loadUsdValues(satoriBalance, evrBalance) {
        try {
            // Fetch SATORI price
            const satoriResponse = await fetch('/api/p2p/pricing/satori');
            if (satoriResponse.ok) {
                const satoriData = await satoriResponse.json();
                if (satoriData.success && satoriData.price && satoriData.price.last) {
                    const satoriPrice = parseFloat(satoriData.price.last) || 0;
                    const satoriUsd = (satoriBalance * satoriPrice).toFixed(2);
                    const tokenEl = document.getElementById('tokenUsdValue');
                    if (tokenEl) tokenEl.textContent = '~$' + satoriUsd + ' USDT';

                    // Also calculate stake USD (assume same price)
                    const stakeEl = document.getElementById('stakeBalance');
                    if (stakeEl && stakeEl.textContent !== '--') {
                        const stakeAmount = parseFloat(stakeEl.textContent) || 0;
                        const stakeUsd = (stakeAmount * satoriPrice).toFixed(2);
                        const stakeUsdEl = document.getElementById('stakeUsdValue');
                        if (stakeUsdEl) stakeUsdEl.textContent = '~$' + stakeUsd + ' USDT';
                    }
                }
            }

            // Fetch EVR price
            const evrResponse = await fetch('/api/p2p/pricing/evr');
            if (evrResponse.ok) {
                const evrData = await evrResponse.json();
                if (evrData.success && evrData.price && evrData.price.last) {
                    const evrPrice = parseFloat(evrData.price.last) || 0;
                    const evrUsd = (evrBalance * evrPrice).toFixed(2);
                    const evrEl = document.getElementById('evrUsdValue');
                    if (evrEl) evrEl.textContent = '~$' + evrUsd + ' USDT';
                }
            }
        } catch (error) {
            console.error('Error loading USD values:', error);
        }
    }

    async function loadAllBalances() {
        // Load both stake (from API) and live balances (from ElectrumX)
        await Promise.all([
            loadBalance(),      // Stake from Satori API
            refreshBalance()    // SATORI and EVR from ElectrumX
        ]);
    }

    async function loadRewardAddress() {
        const result = await apiCall('/peer/reward-address');
        if (result && result.reward_address) {
            document.getElementById('currentRewardAddress').value = result.reward_address;
        }
    }

    async function setRewardAddress() {
        const address = document.getElementById('newRewardAddress').value.trim();
        if (!address) {
            showToast('Please enter an address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }

        // Check if same as current address
        const currentAddress = document.getElementById('currentRewardAddress').value;
        if (address === currentAddress) {
            showToast('This reward address is already set', true);
            document.getElementById('newRewardAddress').value = '';
            return;
        }

        // Backend handles server sync
        const result = await apiCall('/peer/reward-address', 'POST', { reward_address: address });
        if (result && result.success) {
            showToast('Reward address updated');
            loadRewardAddress();
            document.getElementById('newRewardAddress').value = '';
        }
    }

    async function loadStakingStatus() {
        // Get wallet address first
        const walletData = await apiCall('/wallet/address');
        if (!walletData || !walletData.wallet_address) {
            const statusEl = document.getElementById('stakingStatus');
            statusEl.className = 'alert alert-warning';
            statusEl.textContent = 'Unable to load staking status';
            return;
        }

        // Query lender status with wallet address
        const result = await apiCall(`/lender/status?wallet_address=${encodeURIComponent(walletData.wallet_address)}`);
        const statusEl = document.getElementById('stakingStatus');
        const poolAddressEl = document.getElementById('poolAddress');

        if (result && result.pool_address) {
            isStakingToPool = true;
            statusEl.className = 'alert alert-success';
            statusEl.textContent = 'Staking with pool: ' + result.pool_address;
            // Update the pool address input field
            poolAddressEl.value = result.pool_address;
        } else {
            isStakingToPool = false;
            statusEl.className = 'alert alert-secondary';
            statusEl.textContent = 'Not staking with a pool';
            // Clear the pool address input field
            poolAddressEl.value = '';
        }
        updateMutualExclusionUI();
    }

    async function addStakeToPool() {
        const pool = document.getElementById('poolAddress').value.trim();
        if (!pool) {
            showToast('Please enter a pool address', true);
            return;
        }
        if (!isValidAddress(pool)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        const result = await apiCall('/lender/lend', 'POST', { pool_address: pool });
        if (result) {
            showToast('Stake added to pool');
            loadStakingStatus();
        }
    }

    async function removeStakeFromPool() {
        const result = await apiCall('/lender/lend', 'DELETE');
        if (result) {
            showToast('Stake removed from pool');
            loadStakingStatus();
        }
    }

    async function loadAvailablePools() {
        const listEl = document.getElementById('availablePoolsList');
        listEl.innerHTML = '<div class="text-muted small p-2">Loading pools...</div>';

        const result = await apiCall('/pool/open', 'GET');
        if (result && result.pools && result.pools.length > 0) {
            listEl.innerHTML = '';
            // Sort pools by increasing fee percentage (inverted commission)
            result.pools.sort((a, b) => (100 - a.commission) - (100 - b.commission));
            result.pools.forEach(pool => {
                const item = document.createElement('a');
                item.href = '#';
                item.className = 'list-group-item list-group-item-action';
                item.onclick = (e) => {
                    e.preventDefault();
                    document.getElementById('poolAddress').value = pool.address;
                };
                const invertedCommission = 100 - pool.commission;
                const commissionColor = getCommissionColor(invertedCommission);
                item.innerHTML = `
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <div>
                            <small class="text-muted">Address:</small><br>
                            <code class="small">${pool.address}</code>
                        </div>
                        <div class="text-end">
                            ${pool.alias ? `<span class="badge bg-primary">${pool.alias}</span><br>` : ''}
                            <small class="fw-bold" style="color: ${commissionColor}">${invertedCommission}% Fee</small>
                        </div>
                    </div>
                `;
                listEl.appendChild(item);
            });
        } else {
            listEl.innerHTML = '<div class="text-muted small p-2">No open pools available</div>';
        }
    }

    async function setPoolCommission() {
        const commissionInput = document.getElementById('poolCommission');
        let displayedCommission = commissionInput.value ? parseInt(commissionInput.value) : null;

        // Validate
        if (displayedCommission !== null && (displayedCommission < 0 || displayedCommission > 100)) {
            showToast('Commission must be between 0 and 100', true);
            return;
        }

        // Convert inverted value back to actual commission (100 - displayed)
        // Displayed 95% means pool stakers keep 95%, so commission is 5%
        let commission = displayedCommission !== null ? (100 - displayedCommission) : null;

        // Convert 100% commission (0% to stakers) to null (closed)
        if (commission === 100) {
            commission = null;
        }

        const result = await apiCall('/pool/toggle-open', 'POST', { commission: commission });
        if (result) {
            const msg = commission === null ? 'Pool closed' : `Pool open with ${displayedCommission}% Fee`;
            showToast(msg);
            await loadPoolCommission();
            await loadAvailablePools();  // Refresh pool list to show updated commission
            updateMutualExclusionUI();
        }
    }

    async function loadPoolCommission() {
        const commissionInput = document.getElementById('poolCommission');

        const result = await apiCall('/pool/commission', 'GET');
        if (result) {
            // Upstream fix: display as (100 - commission) percentage
            commissionInput.value = result.commission !== null ? (100 - result.commission) : '';
            isOpenPool = result.commission !== null && result.commission > 0;
            updateMutualExclusionUI();  // Update UI after setting isOpenPool
        }
    }

    async function loadWorkers() {
        const workerListEl = document.getElementById('workerList');

        const result = await apiCall('/pool/workers');

        if (result && result.workers && result.workers.length > 0) {
            hasWorkers = true;
            workerListEl.innerHTML = '';
            result.workers.forEach(worker => {
                const workerItem = document.createElement('div');
                workerItem.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';
                workerItem.innerHTML = `
                    <div>
                        <small class="text-muted">Address:</small><br>
                        <code class="small">${worker.address}</code>
                        ${worker.alias ? `<br><span class="badge bg-secondary">${worker.alias}</span>` : ''}
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeWorker('${worker.address}')">
                        <i class="material-icons align-middle" style="font-size: 16px;">delete</i>
                    </button>
                `;
                workerListEl.appendChild(workerItem);
            });
        } else {
            hasWorkers = false;
            workerListEl.innerHTML = '<p class="text-muted">No workers</p>';
        }

        updateMutualExclusionUI();
    }

    async function loadLenders() {
        const lenderListEl = document.getElementById('lenderList');

        const result = await apiCall('/pool/lenders');

        if (result && result.lenders && result.lenders.length > 0) {
            lenderListEl.innerHTML = '';
            result.lenders.forEach(lender => {
                const lenderItem = document.createElement('div');
                lenderItem.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';
                lenderItem.innerHTML = `
                    <div>
                        <small class="text-muted">Address:</small><br>
                        <code class="small">${lender.address}</code>
                        ${lender.alias ? `<br><span class="badge bg-secondary">${lender.alias}</span>` : ''}
                    </div>
                `;
                lenderListEl.appendChild(lenderItem);
            });
        } else {
            lenderListEl.innerHTML = '<p class="text-muted">No pool stakers</p>';
        }
    }

    // Get central-lite API URL
    function getCentralApiUrl() {
        // Always use the production Satori network server for audit files
        return 'https://network.satorinet.io';
    }

    // Helper function to download JSON data as a file
    function downloadJSON(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Download workers audit
    async function downloadWorkersAudit() {
        try {
            const centralApiUrl = getCentralApiUrl();
            const response = await fetch(`${centralApiUrl}/api/v1/audit/workers/latest`);

            if (!response.ok) {
                if (response.status === 404) {
                    showToast('No workers audit available yet', 'warning');
                    return;
                }
                throw new Error(`HTTP ${response.status}`);
            }

            const csvText = await response.text();

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `workers_audit_${timestamp}.csv`;

            // Download CSV file
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            showToast('Workers audit downloaded');
        } catch (error) {
            console.error('Error downloading workers audit:', error);
            showToast('Failed to download workers audit', 'error');
        }
    }

    // Download pool stakers audit
    async function downloadLendersAudit() {
        try {
            const centralApiUrl = getCentralApiUrl();
            const response = await fetch(`${centralApiUrl}/api/v1/audit/stakers/latest`);

            if (!response.ok) {
                if (response.status === 404) {
                    showToast('No pool stakers audit available yet', 'warning');
                    return;
                }
                throw new Error(`HTTP ${response.status}`);
            }

            const csvText = await response.text();

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `stakers_audit_${timestamp}.csv`;

            // Download CSV file
            const blob = new Blob([csvText], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            showToast('Pool stakers audit downloaded');
        } catch (error) {
            console.error('Error downloading pool stakers audit:', error);
            showToast('Failed to download pool stakers audit', 'error');
        }
    }

    function isValidAddress(address) {
        return address && address.length === 34 && address.startsWith('E');
    }

    async function addWorker() {
        const address = document.getElementById('newWorkerAddress').value.trim();
        if (!address) {
            showToast('Please enter a worker address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        const result = await apiCall('/pool/worker', 'POST', { worker_address: address });
        if (result) {
            showToast('Worker added');
            document.getElementById('newWorkerAddress').value = '';
            loadWorkers();
        }
    }

    async function removeWorker(address) {
        const result = await apiCall(`/pool/worker/${address}`, 'DELETE');
        if (result) {
            showToast('Worker removed');
            loadWorkers();
        }
    }

    async function checkHealth() {
        try {
            const response = await fetch('/health');
            const data = await response.json();
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (data.api === 'connected') {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
            } else {
                indicator.className = 'status-indicator status-offline';
                text.textContent = 'Disconnected';
            }
        } catch (error) {
            document.getElementById('statusIndicator').className = 'status-indicator status-offline';
            document.getElementById('statusText').textContent = 'Disconnected';
        }
    }

    async function loadWalletAddresses() {
        const result = await apiCall('/wallet/address');
        if (result) {
            // Main wallet uses vault address
            if (result.vault_address) {
                document.getElementById('walletAddress').value = result.vault_address;
                loadQrCode(result.vault_address);
            } else {
                document.getElementById('walletAddress').value = 'Not available';
                document.getElementById('walletQrCode').innerHTML = '<p class="text-muted mb-0">No address</p>';
            }
            // Identity wallet (for backup)
            if (result.wallet_address) {
                document.getElementById('identityAddress').value = result.wallet_address;
            } else {
                document.getElementById('identityAddress').value = 'Not available';
            }
            // Public keys
            if (result.wallet_public_key) {
                document.getElementById('identityPublicKey').value = result.wallet_public_key;
            } else {
                document.getElementById('identityPublicKey').value = 'Not available';
            }
            if (result.vault_public_key) {
                document.getElementById('vaultPublicKey').value = result.vault_public_key;
            } else {
                document.getElementById('vaultPublicKey').value = 'Not available';
            }
        }
    }

    async function loadP2PIdentity() {
        // Load P2P peer ID and multiaddress
        try {
            const result = await apiCall('/p2p/identify/stats');
            if (result && !result.error) {
                if (result.peer_id) {
                    document.getElementById('p2pPeerId').value = result.peer_id;
                } else {
                    document.getElementById('p2pPeerId').value = 'P2P not initialized';
                }
                if (result.multiaddr) {
                    document.getElementById('p2pMultiaddr').value = result.multiaddr;
                } else {
                    document.getElementById('p2pMultiaddr').value = 'No public address';
                }
            } else {
                document.getElementById('p2pPeerId').value = 'P2P not available';
                document.getElementById('p2pMultiaddr').value = 'P2P not available';
            }
        } catch (e) {
            document.getElementById('p2pPeerId').value = 'P2P not available';
            document.getElementById('p2pMultiaddr').value = 'P2P not available';
        }
    }

    // Identity Wallet functions
    let identityWalletVisible = false;
    let identityPrivateKeyLoaded = false;
    let identityPrivateKeyVisible = false;

    function toggleIdentityWallet() {
        const section = document.getElementById('identityWalletSection');
        identityWalletVisible = !identityWalletVisible;
        section.style.display = identityWalletVisible ? 'block' : 'none';
        // Load P2P identity info when opening
        if (identityWalletVisible) {
            loadP2PIdentity();
        }
    }

    async function toggleIdentityPrivateKey() {
        const input = document.getElementById('identityPrivateKey');
        const icon = document.getElementById('identityKeyIcon');

        if (!identityPrivateKeyLoaded) {
            // Load the identity private key from API
            const result = await apiCall('/wallet/identity-private-key');
            if (result && result.private_key) {
                input.value = result.private_key;
                identityPrivateKeyLoaded = true;
            } else {
                input.value = 'Unable to load';
            }
        }

        identityPrivateKeyVisible = !identityPrivateKeyVisible;
        input.type = identityPrivateKeyVisible ? 'text' : 'password';
        icon.textContent = identityPrivateKeyVisible ? 'visibility_off' : 'visibility';
    }

    function copyIdentityPrivateKey() {
        const input = document.getElementById('identityPrivateKey');
        if (input.value && input.value !== 'Click to reveal...' && input.value !== 'Unable to load') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(input.value).then(() => {
                    showToast('Identity private key copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    input.select();
                    try {
                        document.execCommand('copy');
                        showToast('Identity private key copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy', true);
                    }
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                input.select();
                try {
                    document.execCommand('copy');
                    showToast('Identity private key copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy', true);
                }
            }
        } else {
            showToast('Please reveal the private key first', true);
        }
    }

    function copyToClipboard(elementId) {
        const input = document.getElementById(elementId);
        const value = input.value;
        if (value && value !== 'Loading...' && value !== 'Not available') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(value).then(() => {
                    showToast('Address copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    try {
                        input.select();
                        document.execCommand('copy');
                        showToast('Address copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy address', true);
                    }
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                try {
                    input.select();
                    document.execCommand('copy');
                    showToast('Address copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy address', true);
                }
            }
        } else {
            showToast('No address to copy', true);
        }
    }

    // Wallet Card Functions
    let privateKeyLoaded = false;

    async function loadQrCode(address) {
        const qrContainer = document.getElementById('walletQrCode');
        const result = await apiCall('/wallet/qr/' + encodeURIComponent(address));
        if (result && result.qr_code) {
            qrContainer.innerHTML = '<img src="' + result.qr_code + '" alt="QR Code" style="max-width: 150px;">';
        } else {
            qrContainer.innerHTML = '<p class="text-muted mb-0">QR code unavailable</p>';
        }
    }

    async function togglePrivateKey() {
        const showBtn = document.getElementById('showPrivateKeyBtn');
        const section = document.getElementById('privateKeySection');

        if (section.style.display === 'none') {
            // Show private key (vault private key)
            if (!privateKeyLoaded) {
                const result = await apiCall('/wallet/private-key');
                if (result && result.private_key) {
                    document.getElementById('walletPrivateKey').textContent = result.private_key;
                    privateKeyLoaded = true;
                } else {
                    document.getElementById('walletPrivateKey').textContent = 'Unable to load private key';
                }
            }
            showBtn.style.display = 'none';
            section.style.display = 'block';
        } else {
            // Hide private key
            showBtn.style.display = 'block';
            section.style.display = 'none';
        }
    }

    function copyPrivateKey() {
        const privateKey = document.getElementById('walletPrivateKey').textContent;
        if (privateKey && privateKey !== 'Loading...' && privateKey !== 'Unable to load private key') {
            // Check if Clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(privateKey).then(() => {
                    showToast('Private key copied to clipboard');
                }).catch(() => {
                    // Fallback for older browsers or non-HTTPS
                    const textArea = document.createElement('textarea');
                    textArea.value = privateKey;
                    textArea.style.position = 'fixed';
                    textArea.style.opacity = '0';
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showToast('Private key copied to clipboard');
                    } catch (err) {
                        showToast('Failed to copy private key', true);
                    }
                    document.body.removeChild(textArea);
                });
            } else {
                // Fallback for older browsers or non-HTTPS
                const textArea = document.createElement('textarea');
                textArea.value = privateKey;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast('Private key copied to clipboard');
                } catch (err) {
                    showToast('Failed to copy private key', true);
                }
                document.body.removeChild(textArea);
            }
        }
    }

    function toggleSweepAmount() {
        const sweepCheckbox = document.getElementById('sendSweep');
        const amountInput = document.getElementById('sendAmount');
        if (sweepCheckbox.checked) {
            amountInput.disabled = true;
            amountInput.value = '';
            amountInput.placeholder = 'All tokens';
        } else {
            amountInput.disabled = false;
            amountInput.placeholder = '0.00';
        }
    }

    async function sendTransaction() {
        const address = document.getElementById('sendDestAddress').value.trim();
        const amount = document.getElementById('sendAmount').value;
        const sweep = document.getElementById('sendSweep').checked;
        const sendBtn = document.getElementById('sendBtn');
        const resultDiv = document.getElementById('sendResult');

        // Get selected source (wallet or vault)
        const sendSource = document.querySelector('input[name="sendSource"]:checked').value;
        const sourceName = sendSource === 'wallet' ? 'Identity Wallet' : 'Vault';

        // Validate
        if (!address) {
            showToast('Please enter a destination address', true);
            return;
        }
        if (!isValidAddress(address)) {
            showToast('Invalid address: must start with E and be 34 characters', true);
            return;
        }
        if (!sweep && (!amount || parseFloat(amount) <= 0)) {
            showToast('Please enter an amount or select "Send All"', true);
            return;
        }

        // Confirm with source information
        const confirmMsg = sweep
            ? 'Send ALL tokens from ' + sourceName + ' to ' + address + '?'
            : 'Send ' + amount + ' SATORI from ' + sourceName + ' to ' + address + '?';
        if (!confirm(confirmMsg)) {
            return;
        }

        // Send
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Sending...';
        resultDiv.style.display = 'none';

        try {
            const data = { address: address, sweep: sweep };
            if (!sweep) {
                data.amount = parseFloat(amount);
            }

            // Use the appropriate endpoint based on source selection
            const endpoint = sendSource === 'wallet' ? '/wallet/send-from-wallet' : '/wallet/send';
            const result = await apiCall(endpoint, 'POST', data);

            if (result && result.success) {
                resultDiv.className = 'mt-3 alert alert-success';
                resultDiv.innerHTML = '<strong>Success!</strong><br>Sent from ' + sourceName + '<br>Transaction ID: <code style="word-break: break-all;">' + result.txid + '</code>';
                resultDiv.style.display = 'block';
                showToast('Transaction sent successfully from ' + sourceName + '!');
                // Clear form
                document.getElementById('sendDestAddress').value = '';
                document.getElementById('sendAmount').value = '';
                document.getElementById('sendSweep').checked = false;
                toggleSweepAmount();
                // Refresh balances to show updated amounts
                refreshBalance();
            } else {
                const errorMsg = result ? (result.error || 'Transaction failed') : 'Transaction failed';
                resultDiv.className = 'mt-3 alert alert-danger';
                resultDiv.innerHTML = '<strong>Error:</strong> ' + errorMsg;
                resultDiv.style.display = 'block';
                showToast('Transaction failed: ' + errorMsg, true);
            }
        } catch (error) {
            resultDiv.className = 'mt-3 alert alert-danger';
            resultDiv.innerHTML = '<strong>Error:</strong> ' + error.message;
            resultDiv.style.display = 'block';
            showToast('Transaction error: ' + error.message, true);
        } finally {
            sendBtn.disabled = false;
            sendBtn.innerHTML = '<i class="material-icons align-middle me-1">send</i> Send Transaction';
        }
    }

    // AI Engine Training Frequency Control
    function sliderToSeconds(sliderValue) {
        // Convert slider percentage to seconds (non-linear logarithmic scale)
        // 0% = 24 hours, 25% = 1 hour, 50% = 10 min, 75% = 1 min, 100% = 0 sec
        const percentage = sliderValue / 100.0;

        if (percentage <= 0.0) return 86400;  // 24 hours
        if (percentage >= 1.0) return 0;      // continuous

        // Improved logarithmic scale using exponential decay
        // Maps 0%->86400s (24h), 50%->675s (~11min), 100%->0s (continuous)
        const delay = Math.round(86400 * Math.pow(1 - percentage, 7));
        return delay;
    }

    function secondsToSlider(seconds) {
        // Convert seconds to slider percentage (inverse of sliderToSeconds)
        if (seconds >= 86400) return 0;
        if (seconds <= 0) return 100;

        // Inverse of logarithmic scale
        const percentage = 1 - Math.pow(seconds / 86400, 1/7);
        return Math.round(percentage * 100);
    }

    function formatDelay(seconds) {
        // Format seconds into human-readable string
        if (seconds === 0) return "Continuous";
        if (seconds < 60) return seconds + " seconds";
        if (seconds < 3600) return Math.round(seconds / 60) + " minutes";
        if (seconds < 86400) return Math.round(seconds / 3600) + " hours";
        return Math.round(seconds / 86400) + " days";
    }

    function updateTrainingDelayLabel(sliderValue) {
        // Update label as slider moves
        const seconds = sliderToSeconds(sliderValue);
        document.getElementById('trainingDelayLabel').textContent = formatDelay(seconds);
    }

    async function setTrainingDelay(sliderValue) {
        // Save to backend when slider changes
        const seconds = sliderToSeconds(sliderValue);

        try {
            const result = await apiCall('/engine/training-delay', 'POST', {
                delay_seconds: seconds
            });

            if (result && !result.error) {
                showToast(`Training frequency updated: ${formatDelay(seconds)}`);
            } else {
                showToast('Failed to update training frequency', true);
            }
        } catch (error) {
            console.error('Error setting training delay:', error);
            showToast('Failed to update training frequency', true);
        }
    }

    async function loadTrainingDelay() {
        // Load current setting on page load
        try {
            const result = await apiCall('/engine/training-delay');

            if (result && result.delay_seconds !== undefined) {
                const sliderValue = secondsToSlider(result.delay_seconds);
                document.getElementById('trainingDelaySlider').value = sliderValue;
                updateTrainingDelayLabel(sliderValue);
            }
        } catch (error) {
            console.error('Error loading training delay:', error);
        }
    }

    // =========================================================================
    // DONATION FUNCTIONS
    // =========================================================================

    async function loadTreasuryAddress() {
        const result = await apiCall('/donate/treasury-address');
        if (result && result.treasury_address) {
            document.getElementById('treasuryAddress').value = result.treasury_address;
        } else {
            document.getElementById('treasuryAddress').value = 'Not available';
        }
    }

    async function loadDonationStats() {
        await loadTreasuryAddress();

        const result = await apiCall('/donate/stats');
        if (result) {
            // Update stats
            document.getElementById('donorTotalDonated').textContent =
                result.total_donated ? result.total_donated.toFixed(2) + ' EVR' : '0 EVR';
            document.getElementById('donorTier').textContent = result.tier || 'None';
            document.getElementById('donorRewardsReceived').textContent =
                result.rewards_received ? result.rewards_received.toFixed(4) + ' SAT' : '0 SAT';

            // Update tier progress
            if (result.progress_to_next !== undefined && result.next_tier) {
                const progressPct = Math.min(100, result.progress_to_next * 100);
                document.getElementById('tierProgressBar').style.width = progressPct + '%';
                const remaining = result.next_tier_threshold - result.total_donated;
                document.getElementById('tierProgressText').textContent =
                    remaining > 0 ? remaining.toFixed(0) + ' EVR to ' + result.next_tier : 'Max tier reached!';
            } else if (result.tier === 'Diamond') {
                // Actually at Diamond tier
                document.getElementById('tierProgressBar').style.width = '100%';
                document.getElementById('tierProgressText').textContent = 'Diamond tier achieved!';
            } else {
                // No donations yet or at base tier
                document.getElementById('tierProgressBar').style.width = '0%';
                document.getElementById('tierProgressText').textContent = 'Donate to start earning tiers';
            }
        }
    }

    function updateDonationEstimate() {
        const amount = parseFloat(document.getElementById('donationAmount').value) || 0;
        // Estimate: 1 EVR = 0.01 SATORI (example rate, will be fetched from server)
        const estimatedReward = amount * 0.01;
        document.getElementById('donationEstimate').textContent =
            ' ' + estimatedReward.toFixed(4) + ' SATORI reward';
    }

    async function sendDonation() {
        const amount = parseFloat(document.getElementById('donationAmount').value);
        if (!amount || amount <= 0) {
            showToast('Please enter a valid donation amount', true);
            return;
        }

        const donateBtn = document.getElementById('donateBtn');
        const resultDiv = document.getElementById('donationResult');

        // Confirm
        if (!confirm('Donate ' + amount + ' EVR to the Satori Treasury?')) {
            return;
        }

        donateBtn.disabled = true;
        donateBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Sending...';
        resultDiv.style.display = 'none';

        try {
            const result = await apiCall('/donate/send', 'POST', { amount: amount });

            if (result && result.success) {
                resultDiv.className = 'mt-2 alert alert-success py-2';
                resultDiv.innerHTML = '<small><strong>Success!</strong> TX: <code>' +
                    (result.tx_hash ? result.tx_hash.substring(0, 16) + '...' : 'pending') + '</code></small>';
                resultDiv.style.display = 'block';
                showToast('Donation sent successfully!');
                document.getElementById('donationAmount').value = '';
                loadDonationStats();
                refreshBalance();
            } else {
                const errorMsg = result ? (result.error || 'Donation failed') : 'Donation failed';
                resultDiv.className = 'mt-2 alert alert-danger py-2';
                resultDiv.innerHTML = '<small><strong>Error:</strong> ' + errorMsg + '</small>';
                resultDiv.style.display = 'block';
                showToast('Donation failed: ' + errorMsg, true);
            }
        } catch (error) {
            resultDiv.className = 'mt-2 alert alert-danger py-2';
            resultDiv.innerHTML = '<small><strong>Error:</strong> ' + error.message + '</small>';
            resultDiv.style.display = 'block';
            showToast('Donation error: ' + error.message, true);
        } finally {
            donateBtn.disabled = false;
            donateBtn.innerHTML = '<i class="material-icons align-middle me-1">send</i> Send Donation';
        }
    }

    let topDonorsVisible = false;
    async function toggleTopDonors() {
        const listEl = document.getElementById('topDonorsList');
        topDonorsVisible = !topDonorsVisible;

        if (topDonorsVisible) {
            listEl.style.display = 'block';
            listEl.innerHTML = '<div class="text-muted small">Loading...</div>';

            const result = await apiCall('/donate/top-donors?limit=10');
            if (result && result.donors && result.donors.length > 0) {
                listEl.innerHTML = '<table class="table table-sm mb-0"><thead><tr><th>#</th><th>Address</th><th>Total</th><th>Tier</th></tr></thead><tbody>' +
                    result.donors.map((d, i) => `<tr>
                        <td>${i + 1}</td>
                        <td><code class="small">${d.address ? d.address.substring(0, 10) + '...' : 'Unknown'}</code></td>
                        <td>${d.total_donated ? d.total_donated.toFixed(0) : 0} EVR</td>
                        <td><span class="badge bg-${getTierColor(d.tier)}">${d.tier || 'None'}</span></td>
                    </tr>`).join('') +
                    '</tbody></table>';
            } else {
                listEl.innerHTML = '<div class="text-muted small">No donors yet</div>';
            }
        } else {
            listEl.style.display = 'none';
        }
    }

    function getTierColor(tier) {
        const colors = {
            'bronze': 'warning',
            'silver': 'secondary',
            'gold': 'warning',
            'platinum': 'info',
            'diamond': 'primary'
        };
        return colors[tier?.toLowerCase()] || 'secondary';
    }

    // =========================================================================
    // REFERRAL SYSTEM FUNCTIONS
    // =========================================================================

    const REFERRAL_TIERS = [
        { name: 'None', count: 0, bonus: 0, color: '#9e9e9e' },
        { name: 'Bronze', count: 5, bonus: 2, color: '#cd7f32' },
        { name: 'Silver', count: 25, bonus: 5, color: '#c0c0c0' },
        { name: 'Gold', count: 100, bonus: 8, color: '#ffd700' },
        { name: 'Platinum', count: 500, bonus: 12, color: '#e5e4e2' },
        { name: 'Diamond', count: 2000, bonus: 15, color: '#b9f2ff' }
    ];

    async function loadReferralStats() {
        try {
            const result = await apiCall('/referral/stats');
            if (result) {
                const count = result.referral_count || 0;
                const tier = result.tier || 'None';
                const bonus = result.bonus_percent || 0;

                document.getElementById('referralCount').textContent = count;
                document.getElementById('referralTier').textContent = tier;
                document.getElementById('referralBonus').textContent = '+' + bonus + '%';

                // Set tier color
                const tierInfo = REFERRAL_TIERS.find(t => t.name === tier) || REFERRAL_TIERS[0];
                document.getElementById('referralTier').style.color = tierInfo.color;

                // Calculate progress to next tier
                const currentTierIndex = REFERRAL_TIERS.findIndex(t => t.name === tier);
                const nextTier = REFERRAL_TIERS[currentTierIndex + 1];

                if (nextTier) {
                    document.getElementById('referralNextTier').textContent =
                        (nextTier.count - count) + ' more to ' + nextTier.name;
                    const prevThreshold = tierInfo.count;
                    const nextThreshold = nextTier.count;
                    const progress = ((count - prevThreshold) / (nextThreshold - prevThreshold)) * 100;
                    document.getElementById('referralTierProgressBar').style.width = Math.min(progress, 100) + '%';
                } else {
                    document.getElementById('referralNextTier').textContent = 'Max tier reached!';
                    document.getElementById('referralTierProgressBar').style.width = '100%';
                }
            }
        } catch (error) {
            console.error('Error loading referral stats:', error);
        }

        // Set referral link
        const addressResult = await apiCall('/wallet/address');
        if (addressResult && addressResult.wallet_address) {
            document.getElementById('referralLink').value =
                'https://satorinet.io/download/' + addressResult.wallet_address;
        }
    }

    async function setReferrer() {
        const address = document.getElementById('referrerAddress').value.trim();
        if (!address || address.length !== 34) {
            showToast('Please enter a valid 34-character address', true);
            return;
        }

        try {
            const result = await apiCall('/referral/set', 'POST', { referrer_address: address });
            if (result && result.success) {
                showToast('Referrer set successfully!');
                document.getElementById('referrerAddress').value = '';
            } else {
                showToast(result?.error || 'Failed to set referrer', true);
            }
        } catch (error) {
            showToast('Error setting referrer: ' + error.message, true);
        }
    }

    let topReferrersVisible = false;
    async function toggleTopReferrers() {
        const listEl = document.getElementById('topReferrersList');
        topReferrersVisible = !topReferrersVisible;

        if (topReferrersVisible) {
            listEl.style.display = 'block';
            listEl.innerHTML = '<div class="text-muted small">Loading...</div>';

            const result = await apiCall('/referral/top?limit=10');
            if (result && result.referrers && result.referrers.length > 0) {
                listEl.innerHTML = '<table class="table table-sm mb-0"><thead><tr><th>#</th><th>Address</th><th>Count</th><th>Tier</th><th>Bonus</th></tr></thead><tbody>' +
                    result.referrers.map((r, i) => {
                        const tierInfo = REFERRAL_TIERS.find(t => t.name === r.tier) || REFERRAL_TIERS[0];
                        return `<tr>
                            <td>${i + 1}</td>
                            <td><code class="small">${r.address ? r.address.substring(0, 10) + '...' : 'Unknown'}</code></td>
                            <td>${r.referral_count || 0}</td>
                            <td style="color: ${tierInfo.color};">${r.tier || 'None'}</td>
                            <td style="color: #4CAF50;">+${r.bonus_percent || 0}%</td>
                        </tr>`;
                    }).join('') +
                    '</tbody></table>';
            } else {
                listEl.innerHTML = '<div class="text-muted small">No referrers yet</div>';
            }
        } else {
            listEl.style.display = 'none';
        }
    }

    // =========================================================================
    // TREASURY ALERTS FUNCTIONS
    // =========================================================================

    async function loadTreasuryAlerts() {
        try {
            // Load treasury status
            const status = await apiCall('/p2p/treasury/status');

            if (!status) {
                return;
            }

            // Update treasury levels
            const satoriLevel = document.getElementById('treasurySatoriLevel');
            const evrLevel = document.getElementById('treasuryEvrLevel');
            const alertIcon = document.getElementById('treasuryAlertIcon');
            const alertTitle = document.getElementById('treasuryAlertTitle');

            // Color-code based on severity
            if (status.severity === 'critical') {
                satoriLevel.className = 'h5 mb-0 text-danger';
                evrLevel.className = 'h5 mb-0 text-danger';
                alertIcon.textContent = 'error';
                alertIcon.className = 'material-icons align-middle me-2 text-danger';
                alertTitle.className = 'text-danger';
                alertTitle.textContent = 'Treasury Critical';
            } else if (status.severity === 'warning') {
                satoriLevel.className = 'h5 mb-0 text-warning';
                evrLevel.className = 'h5 mb-0 text-warning';
                alertIcon.textContent = 'warning';
                alertIcon.className = 'material-icons align-middle me-2 text-warning';
                alertTitle.textContent = 'Treasury Warning';
            } else {
                satoriLevel.className = 'h5 mb-0 text-success';
                evrLevel.className = 'h5 mb-0 text-success';
                alertIcon.textContent = 'check_circle';
                alertIcon.className = 'material-icons align-middle me-2 text-success';
                alertTitle.textContent = 'Treasury Healthy';
            }

            satoriLevel.textContent = status.satori_level || 'Normal';
            evrLevel.textContent = status.evr_level || 'Normal';

            // Show active alert banner if there's a current alert
            const banner = document.getElementById('activeAlertBanner');
            const actionButtonsDiv = document.getElementById('alertActionButtons');
            if (status.active_alert) {
                banner.style.display = 'block';
                banner.className = 'alert alert-' + getSeverityClass(status.active_alert.severity) + ' mb-3';
                document.getElementById('alertBannerIcon').textContent = getSeverityIcon(status.active_alert.severity);
                document.getElementById('alertBannerTitle').textContent = status.active_alert.type.replace(/_/g, ' ').toUpperCase();
                document.getElementById('alertBannerMessage').textContent = status.active_alert.message || 'Treasury issue detected';

                // Render action buttons
                actionButtonsDiv.innerHTML = '';
                const actions = status.active_alert.actions || [];
                actions.forEach(action => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-sm ' + getActionButtonClass(action.action_type);
                    btn.innerHTML = `<i class="material-icons align-middle me-1" style="font-size: 14px;">${getActionIcon(action.action_type)}</i>${action.label}`;
                    btn.title = action.description || '';
                    btn.onclick = () => handleAlertAction(action);
                    actionButtonsDiv.appendChild(btn);
                });
            } else {
                banner.style.display = 'none';
                actionButtonsDiv.innerHTML = '';
            }

            // Load deferred rewards
            await loadDeferredRewards();

        } catch (e) {
            console.error('Failed to load treasury alerts:', e);
        }
    }

    async function loadDeferredRewards() {
        try {
            const result = await apiCall('/p2p/treasury/deferred');
            const section = document.getElementById('deferredRewardsSection');

            if (result && result.total_pending > 0) {
                section.style.display = 'block';
                document.getElementById('deferredTotal').textContent =
                    result.total_pending.toFixed(4) + ' SATORI';
                document.getElementById('deferredCount').textContent =
                    result.deferred_count || 0;
            } else {
                section.style.display = 'none';
            }
        } catch (e) {
            console.error('Failed to load deferred rewards:', e);
            document.getElementById('deferredRewardsSection').style.display = 'none';
        }
    }

    let alertHistoryVisible = false;
    async function toggleAlertHistory() {
        const listEl = document.getElementById('alertHistoryList');
        alertHistoryVisible = !alertHistoryVisible;

        if (alertHistoryVisible) {
            listEl.style.display = 'block';
            listEl.innerHTML = '<div class="text-muted small">Loading...</div>';

            const result = await apiCall('/p2p/treasury/alerts/history?limit=10');
            if (result && result.history && result.history.length > 0) {
                listEl.innerHTML = result.history.map(alert => {
                    const date = new Date(alert.timestamp * 1000).toLocaleDateString();
                    const time = new Date(alert.timestamp * 1000).toLocaleTimeString();
                    return `<div class="mb-2 p-2 border-start border-${getSeverityClass(alert.severity)} border-3">
                        <small class="text-muted">${date} ${time}</small><br>
                        <span class="badge bg-${getSeverityClass(alert.severity)} me-1">${alert.severity}</span>
                        <span class="small">${alert.type.replace(/_/g, ' ')}</span>
                    </div>`;
                }).join('');
            } else {
                listEl.innerHTML = '<div class="text-muted small">No alert history</div>';
            }
        } else {
            listEl.style.display = 'none';
        }
    }

    function getSeverityClass(severity) {
        const classes = {
            'critical': 'danger',
            'warning': 'warning',
            'info': 'info'
        };
        return classes[severity?.toLowerCase()] || 'secondary';
    }

    function getSeverityIcon(severity) {
        const icons = {
            'critical': 'error',
            'warning': 'warning',
            'info': 'info'
        };
        return icons[severity?.toLowerCase()] || 'notifications';
    }

    // =========================================================================
    // MY REWARDS HISTORY FUNCTIONS
    // =========================================================================

    async function loadMyRewardsHistory() {
        try {
            const result = await apiCall('/p2p/distribution/history?limit=20');

            if (!result) {
                document.getElementById('rewardsHistoryList').innerHTML =
                    '<div class="text-muted small text-center py-3">Failed to load rewards</div>';
                return;
            }

            // Update summary stats
            const totalEarned = result.total_earned || 0;
            document.getElementById('rewardsTotalEarned').textContent =
                totalEarned > 0 ? totalEarned.toFixed(2) + ' SATORI' : '--';

            const distributions = result.distributions || [];
            document.getElementById('rewardsDistCount').textContent = distributions.length || '--';

            // Calculate this month's earnings
            const now = new Date();
            const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1).getTime() / 1000;
            const thisMonthEarnings = distributions
                .filter(d => d.timestamp >= thisMonthStart)
                .reduce((sum, d) => sum + (d.amount || 0), 0);
            document.getElementById('rewardsThisMonth').textContent =
                thisMonthEarnings > 0 ? thisMonthEarnings.toFixed(2) + ' SATORI' : '--';

            // Update history list
            const container = document.getElementById('rewardsHistoryList');

            if (distributions.length === 0) {
                container.innerHTML = '<div class="text-muted small text-center py-3">No rewards received yet</div>';
                return;
            }

            container.innerHTML = distributions.slice(0, 10).map(dist => {
                const date = new Date(dist.timestamp * 1000);
                const dateStr = date.toLocaleDateString();
                const amount = (dist.amount || 0).toFixed(4);
                const roundId = dist.round_id || '--';

                return `<div class="list-group-item py-2 px-3">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <span class="badge bg-success me-2">+${amount}</span>
                            <small class="text-muted">SATORI</small>
                        </div>
                        <small class="text-muted">${dateStr}</small>
                    </div>
                    <div class="d-flex justify-content-between mt-1">
                        <small class="text-muted">Round #${roundId}</small>
                        <small class="text-muted">${dist.stream_count || '--'} streams</small>
                    </div>
                </div>`;
            }).join('');

        } catch (e) {
            console.error('Failed to load rewards history:', e);
            document.getElementById('rewardsHistoryList').innerHTML =
                '<div class="text-danger small text-center py-3">Error loading rewards</div>';
        }
    }

    // =========================================================================
    // PREDICTION STATS FUNCTIONS
    // =========================================================================

    async function loadPredictionStats() {
        try {
            // Load prediction stats and claimed streams in parallel
            const [stats, claimsResult] = await Promise.all([
                apiCall('/p2p/predictions/stats'),
                apiCall('/p2p/streams/my-claims')
            ]);
            // Use claimed streams count (P2P claims), not all Engine models
            const claimedStreams = claimsResult?.count || 0;

            if (stats) {
                // Update summary stats
                document.getElementById('predictionCount').textContent = stats.my_predictions || 0;
                // Use claimed streams count (P2P), not all Engine models (includes Central Server streams)
                document.getElementById('predictionStreams').textContent = claimedStreams;

                // Accuracy from average score (score is 0-1, convert to %)
                const accuracy = stats.my_average_score ? (stats.my_average_score * 100).toFixed(1) + '%' : '--%';
                document.getElementById('predictionAccuracy').textContent = accuracy;

                // Update status
                const statusAlert = document.getElementById('predictionStatus');
                const statusText = document.getElementById('predictionStatusText');

                if (claimedStreams > 0) {
                    statusAlert.className = 'alert alert-success py-2 mb-0';
                    statusText.textContent = 'Active - Predicting on ' + claimedStreams + ' streams';
                } else if (stats.started) {
                    statusAlert.className = 'alert alert-warning py-2 mb-0';
                    statusText.textContent = 'Protocol active - Claim streams to start predicting';
                } else {
                    statusAlert.className = 'alert alert-secondary py-2 mb-0';
                    statusText.textContent = 'Not started - Claim streams to begin';
                }
            }

            // Load recent scores
            const scores = await apiCall('/p2p/predictions/scores?limit=5');
            const scoresList = document.getElementById('recentScoresList');

            if (scores && scores.scores && scores.scores.length > 0) {
                scoresList.innerHTML = scores.scores.map(score => {
                    const scoreColor = score.score >= 0.7 ? 'text-success' : (score.score >= 0.4 ? 'text-warning' : 'text-danger');
                    const scorePct = (score.score * 100).toFixed(0) + '%';
                    const streamShort = score.stream_id ? score.stream_id.split('|').slice(-2).join('/') : 'unknown';
                    return `<div class="list-group-item py-1 px-2 d-flex justify-content-between">
                        <span class="text-muted small">${streamShort}</span>
                        <span class="badge ${scoreColor}">${scorePct}</span>
                    </div>`;
                }).join('');
            } else {
                scoresList.innerHTML = '<div class="text-muted small p-2">No scores yet</div>';
            }
        } catch (e) {
            console.error('Failed to load prediction stats:', e);
        }
    }

    function getActionButtonClass(actionType) {
        const classes = {
            'donate_evr': 'btn-success',
            'view_status': 'btn-outline-secondary',
            'none': 'btn-outline-secondary'
        };
        return classes[actionType] || 'btn-outline-secondary';
    }

    function getActionIcon(actionType) {
        const icons = {
            'donate_evr': 'volunteer_activism',
            'view_status': 'info',
            'none': 'arrow_forward'
        };
        return icons[actionType] || 'arrow_forward';
    }

    function handleAlertAction(action) {
        if (action.action_type === 'donate_evr') {
            // Scroll to and expand the donate section
            const donateCollapse = document.getElementById('donateCollapse');
            if (donateCollapse && !donateCollapse.classList.contains('show')) {
                new bootstrap.Collapse(donateCollapse, {show: true});
            }
            // Scroll to the donate section
            document.querySelector('[data-bs-target="#donateCollapse"]')?.scrollIntoView({behavior: 'smooth'});
            showToast('Scroll down to the Donate section to send EVR to treasury');
        } else if (action.action_type === 'view_status') {
            loadTreasuryAlerts();
            showToast('Treasury status refreshed');
        }
    }

    // =========================================================================
    // AI ENGINE PERFORMANCE CHARTS (from upstream)
    // =========================================================================
    let predVsObsChart = null;
    let accuracyChart = null;

    async function loadPerformance() {
        try {
            const data = await apiCall('/engine/performance');

            if (!data || data.error) {
                // Show message to user
                if (data?.error) {
                    showToast('Performance data unavailable: ' + data.error, true);
                }
                return;
            }

            // Check if we have any data
            const hasData = (data.observations && data.observations.length > 0) ||
                           (data.predictions && data.predictions.length > 0);

            if (!hasData) {
                // Update stats to show no data
                document.getElementById('accuracyPct').textContent = '--';
                document.getElementById('avgError').textContent = 'No data yet';
                document.getElementById('avgAbsError').textContent = '--';
                return;
            }

            // Update stats
            if (data.stats) {
                document.getElementById('accuracyPct').textContent =
                    data.stats.accuracy_pct ? `${data.stats.accuracy_pct}%` : '--';
                document.getElementById('avgError').textContent =
                    data.stats.avg_error !== undefined ? data.stats.avg_error.toFixed(2) : '--';
                document.getElementById('avgAbsError').textContent =
                    data.stats.avg_abs_error !== undefined ? data.stats.avg_abs_error.toFixed(2) : '--';
            }

            renderPredVsObsChart(data.observations, data.predictions, data.accuracy);
            renderAccuracyChart(data.accuracy);
        } catch (error) {
            console.error('Error loading performance data:', error);
            showToast('Failed to load performance data', true);
        }
    }

    function renderPredVsObsChart(observations, predictions, accuracyData) {
        try {
            const ctx = document.getElementById('predVsObsChart');
            if (!ctx) {
                console.error('Chart canvas element not found: predVsObsChart');
                return;
            }

            if (predVsObsChart) predVsObsChart.destroy();

            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#a0a0a0' : '#555555';
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)';

            // Helper function to parse timestamp (handles both Unix timestamps and date strings)
            const parseTimestamp = (ts) => {
                // Check if it's a pure numeric string (Unix timestamp)
                if (/^\d+\.?\d*$/.test(ts)) {
                    const numTs = parseFloat(ts);
                    // Unix timestamp - multiply by 1000 if in seconds
                    return numTs < 10000000000 ? new Date(numTs * 1000) : new Date(numTs);
                } else {
                    // Date string (like "2025-12-21 06:55:47.484299")
                    // Add 'Z' to parse as UTC if not already present
                    const dateStr = ts.includes('Z') ? ts : ts.replace(' ', 'T') + 'Z';
                    return new Date(dateStr);
                }
            };

            // Convert observations data - use sequential positions
            const obsData = observations.map((o, i) => ({
                x: i,  // Use index as x-position
                y: parseFloat(o.value)
            }));

            // Convert predictions data - shift forward by 1 position
            // prediction[i] should be at position i+1 to align with observation[i+1]
            const predData = predictions.map((p, i) => ({
                x: i + 1,  // Shift forward: pred[0] at position 1, pred[1] at position 2, etc.
                y: parseFloat(p.value)
            }));

            // Create index-based lookup maps
            // observation[i] -> prediction[i+1] (observation produces next prediction)
            // prediction[i] -> observation[i-1] (prediction was made from previous observation)
            const obsToPredMap = new Map();
            const predToObsMap = new Map();

            // Build obsToPredMap: observation[i] maps to prediction[i+1]
            observations.forEach((obs, i) => {
                if (i + 1 < predictions.length) {
                    const nextPred = predictions[i + 1];
                    obsToPredMap.set(obs.ts, {
                        ts: nextPred.ts,
                        value: parseFloat(nextPred.value),
                        timestamp: parseTimestamp(nextPred.ts)
                    });
                }
                // First observation has no prediction to show (it produces the next one)
            });

            // Build predToObsMap: prediction[i] maps to observation[i-1]
            predictions.forEach((pred, i) => {
                if (i - 1 >= 0 && i - 1 < observations.length) {
                    const prevObs = observations[i - 1];
                    predToObsMap.set(pred.ts, {
                        ts: prevObs.ts,
                        value: parseFloat(prevObs.value),
                        timestamp: parseTimestamp(prevObs.ts)
                    });
                }
                // First prediction has no prior observation in our data
            });

            predVsObsChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Observations',
                    data: obsData,
                    borderColor: 'rgb(75, 192, 192)',
                    borderWidth: 2,
                    pointRadius: 2
                }, {
                    label: 'Predictions',
                    data: predData,
                    borderColor: 'rgb(153, 102, 255)',
                    borderWidth: 2,
                    pointRadius: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            color: textColor,
                            callback: function(value, index) {
                                // Show timestamp labels for select points
                                if (index >= observations.length - 3 || index === 0) {
                                    const obs = observations[value];
                                    if (obs) {
                                        return new Date(parseTimestamp(obs.ts)).toLocaleTimeString();
                                    }
                                }
                                return '';
                            }
                        },
                        grid: { color: gridColor }
                    },
                    y: {
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        mode: 'point',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = Math.round(tooltipItems[0].parsed.x);
                                const obs = observations[index];
                                if (obs) {
                                    return new Date(parseTimestamp(obs.ts)).toLocaleString();
                                }
                                return 'Index: ' + index;
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label;
                                const value = context.parsed.y;
                                const position = Math.round(context.parsed.x);

                                if (datasetLabel === 'Observations') {
                                    // observation is at position i
                                    const obsData = observations[position];
                                    if (!obsData) {
                                        // No observation at this position (future prediction only)
                                        return null;
                                    }
                                    const obsTime = new Date(parseTimestamp(obsData.ts)).toLocaleTimeString();
                                    return `Observation: ${value.toFixed(2)} (at ${obsTime})`;

                                } else if (datasetLabel === 'Predictions') {
                                    // prediction[i] is at position i+1, so prediction at position p is predictions[p-1]
                                    const predIndex = position - 1;
                                    if (predIndex < 0 || predIndex >= predictions.length) {
                                        // No prediction at this position (first observation has no prediction)
                                        return null;
                                    }
                                    const predData = predictions[predIndex];
                                    if (!predData) {
                                        return null;
                                    }
                                    const predTime = new Date(parseTimestamp(predData.ts)).toLocaleTimeString();
                                    return `Prediction: ${value.toFixed(2)} (at ${predTime})`;
                                }

                                return null;
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'point',
                    intersect: false
                }
            }
        });
        } catch (error) {
            console.error('Error rendering predictions vs observations chart:', error);
            showToast('Error rendering chart: ' + error.message, true);
        }
    }

    function renderAccuracyChart(accuracyData) {
        try {
            const ctx = document.getElementById('accuracyChart');
            if (!ctx) {
                console.error('Chart canvas element not found: accuracyChart');
                return;
            }

            if (accuracyChart) accuracyChart.destroy();

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const textColor = isDark ? '#a0a0a0' : '#555555';
        const gridColor = isDark ? 'rgba(255, 255, 255, 0.08)' : 'rgba(0, 0, 0, 0.08)';

        // Helper function to parse timestamp (same as in renderPredVsObsChart)
        const parseTimestamp = (ts) => {
            if (/^\d+\.?\d*$/.test(ts)) {
                const numTs = parseFloat(ts);
                return numTs < 10000000000 ? new Date(numTs * 1000) : new Date(numTs);
            } else {
                const dateStr = ts.includes('Z') ? ts : ts.replace(' ', 'T') + 'Z';
                return new Date(dateStr);
            }
        };

        accuracyChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Absolute Error',
                    data: accuracyData.map((a, i) => ({ x: i, y: a.abs_error })),
                    borderColor: 'rgb(255, 99, 132)',
                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                    borderWidth: 2,
                    pointRadius: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            color: textColor,
                            callback: function(value, index) {
                                // Show timestamp labels for select points
                                if (index >= accuracyData.length - 3 || index === 0) {
                                    const acc = accuracyData[value];
                                    if (acc) {
                                        return parseTimestamp(acc.ts).toLocaleTimeString();
                                    }
                                }
                                return '';
                            }
                        },
                        grid: { color: gridColor }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: { color: textColor },
                        grid: { color: gridColor }
                    }
                },
                plugins: {
                    legend: { labels: { color: textColor } },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = Math.round(tooltipItems[0].parsed.x);
                                const acc = accuracyData[index];
                                if (acc) {
                                    return parseTimestamp(acc.ts).toLocaleString();
                                }
                                return 'Index: ' + index;
                            },
                            label: function(context) {
                                return 'Absolute Error: ' + context.parsed.y.toFixed(4);
                            }
                        }
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
        });
        } catch (error) {
            console.error('Error rendering accuracy chart:', error);
            showToast('Error rendering accuracy chart: ' + error.message, true);
        }
    }

    function refreshPerformance() {
        showToast('Refreshing performance data...', 'info');
        loadPerformance();
    }

    // Wallet Import Functionality
    let walletImportFilesModal = [];

    function openImportWalletModal() {
        const modal = new bootstrap.Modal(document.getElementById('importWalletModal'));
        modal.show();
    }

    function handleWalletFolderSelectModal(event) {
        const files = Array.from(event.target.files);
        const importBtn = document.getElementById('importWalletBtnModal');
        const fileListDiv = document.getElementById('importFileListModal');
        const fileListItems = document.getElementById('importFileListItemsModal');

        walletImportFilesModal = [];
        fileListItems.innerHTML = '';

        if (files.length === 0) {
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Validate folder name is "wallet"
        const firstFile = files[0];
        const pathParts = firstFile.webkitRelativePath.split('/');
        const folderName = pathParts[0];

        if (folderName !== 'wallet') {
            showToast('Please select a folder named "wallet"', true);
            event.target.value = '';
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Filter to only .yaml files
        const yamlFiles = files.filter(f =>
            f.name.endsWith('.yaml') || f.name.endsWith('.yml')
        );

        // Check for required files
        const fileNames = yamlFiles.map(f => f.name);
        const hasWallet = fileNames.includes('wallet.yaml');
        const hasVault = fileNames.includes('vault.yaml');

        if (!hasWallet || !hasVault) {
            showToast('Wallet folder must contain wallet.yaml and vault.yaml', true);
            event.target.value = '';
            importBtn.disabled = true;
            fileListDiv.style.display = 'none';
            return;
        }

        // Valid files - show list
        walletImportFilesModal = yamlFiles;
        fileListItems.innerHTML = '';
        yamlFiles.forEach(file => {
            const li = document.createElement('li');
            li.innerHTML = `<code>${file.name}</code> (${(file.size / 1024).toFixed(2)} KB)`;
            fileListItems.appendChild(li);
        });

        fileListDiv.style.display = 'block';
        importBtn.disabled = false;
    }

    async function importWalletFromModal() {
        if (walletImportFilesModal.length === 0) {
            showToast('No files selected', true);
            return;
        }

        const importBtn = document.getElementById('importWalletBtnModal');
        const resultDiv = document.getElementById('importResultModal');

        // Confirm action
        const confirmMsg =
            'WARNING: This will replace your current wallet and restart the container!\n\n' +
            `Files to import: ${walletImportFilesModal.map(f => f.name).join(', ')}\n\n` +
            'Make sure you have backed up your current wallet.\n\n' +
            'Continue?';

        if (!confirm(confirmMsg)) {
            return;
        }

        // Disable button and show loading
        importBtn.disabled = true;
        importBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Importing...';
        resultDiv.style.display = 'none';

        try {
            // Prepare FormData
            const formData = new FormData();
            walletImportFilesModal.forEach(file => {
                formData.append('files', file, file.name);
            });

            // Upload files
            const response = await fetch('/api/wallet/import', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (response.ok && data.success) {
                resultDiv.className = 'mt-3 alert alert-success';
                resultDiv.innerHTML =
                    '<strong>Success!</strong><br>' +
                    'Wallet imported successfully.<br>' +
                    'Container is restarting...<br>' +
                    '<small>Backup saved to: ' + data.backup_location + '</small><br>' +
                    '<small class="text-warning">Note: You\'ll need to set a new reward address after restart.</small>';
                resultDiv.style.display = 'block';

                showToast('Wallet imported! Container restarting...');

                // Show restart notice
                setTimeout(() => {
                    alert(
                        'Container Restarting\n\n' +
                        'The application is restarting with your imported wallet.\n' +
                        'Please wait 10-15 seconds, then refresh this page.\n\n' +
                        'You will need to:\n' +
                        '1. Log in again with your vault password\n' +
                        '2. Set a new reward address for this wallet'
                    );

                    // Auto-reload after 15 seconds
                    setTimeout(() => {
                        window.location.href = '/login';
                    }, 15000);
                }, 2000);

            } else {
                const errorMsg = data.error || 'Import failed';
                const rolledBack = data.rolled_back ? '\n\nYour old wallet has been restored.' : '';
                resultDiv.className = 'mt-3 alert alert-danger';
                resultDiv.innerHTML = '<strong>Error:</strong> ' + errorMsg + rolledBack;
                resultDiv.style.display = 'block';
                showToast('Import failed: ' + errorMsg, true);

                // Re-enable button
                importBtn.disabled = false;
                importBtn.innerHTML = '<i class="material-icons align-middle me-1">upload</i> Import Wallet & Restart';
            }

        } catch (error) {
            resultDiv.className = 'mt-3 alert alert-danger';
            resultDiv.innerHTML = '<strong>Error:</strong> ' + error.message;
            resultDiv.style.display = 'block';
            showToast('Import error: ' + error.message, true);

            // Re-enable button
            importBtn.disabled = false;
            importBtn.innerHTML = '<i class="material-icons align-middle me-1">upload</i> Import Wallet & Restart';
        }
    }

    // =========================================================================
    // STREAM ONBOARDING FUNCTIONS
    // =========================================================================

    // Load levels: Light=5, Medium=15, Heavy=30
    const LOAD_LEVELS = {
        light: 5,
        medium: 15,
        heavy: 30
    };

    let selectedLoadLevel = 'medium';  // Default to medium
    let availableStreams = [];  // Cached list of available streams
    let selectedStreamIds = new Set();  // For manual selection
    let onboardingTimeoutId = null;  // Auto-pick timeout
    let onboardingCountdown = 180;  // 3 minutes

    function selectLoadLevel(level) {
        selectedLoadLevel = level;
        // Update UI
        document.querySelectorAll('.load-level-card').forEach(card => {
            if (card.dataset.level === level) {
                card.classList.add('selected');
                card.style.border = '2px solid var(--accent-color)';
            } else {
                card.classList.remove('selected');
                card.style.border = '';
            }
        });
    }

    async function loadAvailableStreams() {
        try {
            // Load streams with activity info
            const result = await apiCall('/p2p/streams/discover?limit=200');
            if (result && result.streams) {
                // Sort by activity (active streams first)
                availableStreams = result.streams.sort((a, b) => {
                    // Active streams first
                    if (a.is_active && !b.is_active) return -1;
                    if (!a.is_active && b.is_active) return 1;
                    // Then by last observation time (most recent first)
                    return (b.last_observation_time || 0) - (a.last_observation_time || 0);
                });
                renderStreamsList();
            }
        } catch (e) {
            console.error('Failed to load streams:', e);
        }
    }

    function renderStreamsList() {
        const container = document.getElementById('streamsList');
        if (!availableStreams || availableStreams.length === 0) {
            container.innerHTML = `<div class="text-center py-4">
                <i class="material-icons text-muted" style="font-size: 48px;">cloud_off</i>
                <p class="text-muted mt-2 mb-3">No streams available yet.</p>
                <p class="small text-muted">Be the first to create a data stream!</p>
                <a href="/oracle" class="btn btn-danger btn-sm">
                    <i class="material-icons align-middle me-1" style="font-size: 16px;">add</i>
                    Become a Primary Oracle
                </a>
            </div>`;
            return;
        }

        container.innerHTML = availableStreams.map(stream => {
            const streamId = stream.stream_id;
            const displayName = streamId.split('|').slice(2).join('/') || streamId;
            const source = stream.source || 'unknown';
            const isSelected = selectedStreamIds.has(streamId);
            const isActive = stream.is_active;

            // Format last observation time
            let activityInfo = '';
            if (stream.last_observation_time > 0) {
                const ageSeconds = Math.floor(Date.now() / 1000 - stream.last_observation_time);
                if (ageSeconds < 60) {
                    activityInfo = `${ageSeconds}s ago`;
                } else if (ageSeconds < 3600) {
                    activityInfo = `${Math.floor(ageSeconds / 60)}m ago`;
                } else {
                    activityInfo = `${Math.floor(ageSeconds / 3600)}h ago`;
                }
            }

            return `
                <label class="list-group-item d-flex align-items-center stream-item" data-stream-id="${streamId}">
                    <input type="checkbox" class="form-check-input me-2 stream-checkbox"
                           value="${streamId}"
                           ${isSelected ? 'checked' : ''}
                           onchange="toggleStreamSelection('${streamId}', this.checked)">
                    <div class="flex-grow-1">
                        <span class="fw-medium">${displayName}</span>
                        ${isActive ? '<span class="badge bg-success ms-2">Active</span>' : ''}
                        <br><small class="text-muted">Source: ${source}${activityInfo ? ' | Last: ' + activityInfo : ''}</small>
                    </div>
                </label>
            `;
        }).join('');
    }

    function filterStreamsList() {
        const query = document.getElementById('streamSearchInput').value.toLowerCase();
        document.querySelectorAll('.stream-item').forEach(item => {
            const streamId = item.dataset.streamId.toLowerCase();
            item.style.display = streamId.includes(query) ? '' : 'none';
        });
    }

    function toggleStreamSelection(streamId, selected) {
        if (selected) {
            selectedStreamIds.add(streamId);
        } else {
            selectedStreamIds.delete(streamId);
        }
        updateSelectedCount();
    }

    function selectAllStreams() {
        availableStreams.forEach(s => selectedStreamIds.add(s.stream_id));
        document.querySelectorAll('.stream-checkbox').forEach(cb => cb.checked = true);
        updateSelectedCount();
    }

    function deselectAllStreams() {
        selectedStreamIds.clear();
        document.querySelectorAll('.stream-checkbox').forEach(cb => cb.checked = false);
        updateSelectedCount();
    }

    function updateSelectedCount() {
        document.getElementById('selectedStreamCount').textContent = selectedStreamIds.size;
        document.getElementById('claimSelectedBtn').disabled = selectedStreamIds.size === 0;
    }

    async function autoPickStreams() {
        const targetCount = LOAD_LEVELS[selectedLoadLevel];
        const progressDiv = document.getElementById('autoPickProgress');
        const progressBar = document.getElementById('autoPickProgressBar');
        const statusEl = document.getElementById('autoPickStatus');

        progressDiv.style.display = 'block';
        progressBar.style.width = '10%';
        statusEl.textContent = 'Finding active streams...';

        // Stop the auto-timeout
        stopOnboardingTimeout();

        try {
            // First discover available streams (prefer active ones)
            const result = await apiCall('/p2p/streams/discover?limit=200');
            progressBar.style.width = '30%';

            if (!result || !result.streams || result.streams.length === 0) {
                statusEl.textContent = 'No streams available. Please try again later.';
                progressBar.classList.remove('progress-bar-animated');
                progressBar.classList.add('bg-warning');
                return;
            }

            // Sort by activity (active streams first), then take top N
            const sortedStreams = result.streams.sort((a, b) => {
                // Active streams first
                if (a.is_active && !b.is_active) return -1;
                if (!a.is_active && b.is_active) return 1;
                // Then by last observation time (most recent first)
                return (b.last_observation_time || 0) - (a.last_observation_time || 0);
            });
            const streamsToClaim = sortedStreams.slice(0, targetCount);
            statusEl.textContent = `Claiming ${streamsToClaim.length} streams...`;
            progressBar.style.width = '40%';

            let claimed = 0;
            let failed = 0;

            for (let i = 0; i < streamsToClaim.length; i++) {
                const stream = streamsToClaim[i];
                try {
                    const claimResult = await apiCall('/p2p/streams/claim', 'POST', {
                        stream_id: stream.stream_id
                    });
                    if (claimResult && claimResult.success) {
                        claimed++;
                    } else {
                        failed++;
                    }
                } catch (e) {
                    failed++;
                }

                const progress = 40 + ((i + 1) / streamsToClaim.length) * 55;
                progressBar.style.width = progress + '%';
                statusEl.textContent = `Claimed ${claimed}/${streamsToClaim.length} streams...`;
            }

            progressBar.style.width = '100%';
            progressBar.classList.remove('progress-bar-animated');

            if (claimed > 0) {
                progressBar.classList.add('bg-success');
                statusEl.textContent = `Successfully claimed ${claimed} streams! ${failed > 0 ? `(${failed} failed)` : ''}`;

                // Close modal after short delay
                setTimeout(() => {
                    closeOnboardingModal();
                    loadPredictionStats();  // Refresh prediction stats
                    showToast(`Claimed ${claimed} streams. AI predictions starting...`);
                }, 1500);
            } else {
                progressBar.classList.add('bg-danger');
                statusEl.textContent = 'Failed to claim any streams. Please try manual selection.';
            }

        } catch (e) {
            console.error('Auto-pick failed:', e);
            progressBar.classList.add('bg-danger');
            statusEl.textContent = 'Error: ' + e.message;
        }
    }

    async function claimSelectedStreams() {
        if (selectedStreamIds.size === 0) return;

        const btn = document.getElementById('claimSelectedBtn');
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Claiming...';

        // Stop the auto-timeout
        stopOnboardingTimeout();

        let claimed = 0;
        let failed = 0;

        for (const streamId of selectedStreamIds) {
            try {
                const result = await apiCall('/p2p/streams/claim', 'POST', {
                    stream_id: streamId
                });
                if (result && result.success) {
                    claimed++;
                } else {
                    failed++;
                }
            } catch (e) {
                failed++;
            }
        }

        btn.innerHTML = '<i class="material-icons align-middle me-1">check_circle</i> Claim Selected Streams';
        btn.disabled = false;

        if (claimed > 0) {
            closeOnboardingModal();
            loadPredictionStats();
            showToast(`Claimed ${claimed} streams. ${failed > 0 ? `(${failed} failed)` : ''}`);
        } else {
            showToast('Failed to claim any streams', true);
        }
    }

    function skipOnboarding() {
        // Mark as skipped in localStorage
        localStorage.setItem('satori-onboarding-skipped', 'true');
        stopOnboardingTimeout();
        closeOnboardingModal();
        showToast('Onboarding skipped. Claim streams from Predictions page when ready.');
    }

    function closeOnboardingModal() {
        const modal = bootstrap.Modal.getInstance(document.getElementById('streamOnboardingModal'));
        if (modal) {
            modal.hide();
        }
        stopOnboardingTimeout();
    }

    function startOnboardingTimeout() {
        onboardingCountdown = 180;  // 3 minutes
        document.getElementById('autoTimeoutCountdown').textContent = onboardingCountdown;

        onboardingTimeoutId = setInterval(() => {
            onboardingCountdown--;
            document.getElementById('autoTimeoutCountdown').textContent = onboardingCountdown;

            if (onboardingCountdown <= 0) {
                stopOnboardingTimeout();
                // Auto-pick with medium load level
                selectLoadLevel('medium');
                autoPickStreams();
            }
        }, 1000);
    }

    function stopOnboardingTimeout() {
        if (onboardingTimeoutId) {
            clearInterval(onboardingTimeoutId);
            onboardingTimeoutId = null;
        }
        // Hide the timeout notice
        const notice = document.getElementById('autoTimeoutNotice');
        if (notice) {
            notice.style.display = 'none';
        }
    }

    async function checkAndShowOnboarding() {
        // Skip if already dismissed
        if (localStorage.getItem('satori-onboarding-skipped') === 'true') {
            return;
        }

        try {
            // Check if user already has claimed streams
            const myStreams = await apiCall('/p2p/streams/my');
            if (myStreams && myStreams.streams && myStreams.streams.length > 0) {
                // Already has streams, no need for onboarding
                return;
            }

            // Also check Engine status
            const engineStatus = await apiCall('/p2p/streams/engine-status');
            if (engineStatus && engineStatus.active_models > 0) {
                // Already has active models
                return;
            }

            // Show onboarding modal
            const modal = new bootstrap.Modal(document.getElementById('streamOnboardingModal'));
            modal.show();

            // Load available streams for manual selection
            loadAvailableStreams();

            // Start auto-timeout countdown
            startOnboardingTimeout();

        } catch (e) {
            console.error('Failed to check onboarding status:', e);
        }
    }

    // Tab change handler for onboarding modal - stop timeout when switching tabs
    document.addEventListener('shown.bs.tab', function(e) {
        if (e.target.id === 'manual-pick-tab' || e.target.id === 'skip-tab') {
            stopOnboardingTimeout();
        } else if (e.target.id === 'auto-pick-tab') {
            // Restart timeout when going back to auto-pick
            startOnboardingTimeout();
        }
    });

    // =========================================================================
    // MY CLAIMED STREAMS FUNCTIONS
    // =========================================================================

    async function loadMyClaims() {
        const tbody = document.getElementById('myClaimsTable');
        const countBadge = document.getElementById('claimedStreamsCount');

        try {
            const result = await apiCall('/p2p/streams/my-claims');
            const claims = result?.claims || [];
            countBadge.textContent = claims.length;

            if (claims.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-center text-muted py-3">No claimed streams. Use the onboarding modal or claim streams from the Oracle page.</td></tr>';
                return;
            }

            const now = Math.floor(Date.now() / 1000);
            const GRACE_PERIOD = 1800;  // 30 minutes

            tbody.innerHTML = claims.map(claim => {
                const streamId = claim.stream_id || '';
                const displayName = streamId.split('|').slice(2).join('/') || streamId;
                const slot = claim.slot_index ?? '--';
                const claimedDate = claim.timestamp ? new Date(claim.timestamp * 1000).toLocaleString() : '--';

                // Calculate expiry status
                let expiryText = 'Never';
                let statusBadge = '<span class="badge bg-success">Active</span>';
                let timeToExpiry = 0;

                if (claim.expires && claim.expires > 0) {
                    timeToExpiry = claim.expires - now;
                    const expiryDate = new Date(claim.expires * 1000);

                    if (timeToExpiry > 0) {
                        // Not expired yet
                        const hours = Math.floor(timeToExpiry / 3600);
                        const mins = Math.floor((timeToExpiry % 3600) / 60);

                        if (hours > 0) {
                            expiryText = `${hours}h ${mins}m`;
                        } else {
                            expiryText = `${mins}m`;
                        }

                        // Warning if expiring soon (less than 2 hours)
                        if (timeToExpiry < 7200) {
                            statusBadge = '<span class="badge bg-warning text-dark">Expiring Soon</span>';
                        }
                    } else if (timeToExpiry > -GRACE_PERIOD) {
                        // In grace period
                        const graceMins = Math.floor((GRACE_PERIOD + timeToExpiry) / 60);
                        expiryText = `Grace: ${graceMins}m`;
                        statusBadge = '<span class="badge bg-danger">Grace Period</span>';
                    } else {
                        // Fully expired
                        expiryText = 'Expired';
                        statusBadge = '<span class="badge bg-dark">Expired</span>';
                    }
                }

                return `<tr>
                    <td><code title="${streamId}">${displayName}</code></td>
                    <td>${slot}</td>
                    <td><small>${claimedDate}</small></td>
                    <td>${expiryText}</td>
                    <td>${statusBadge}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-danger" onclick="releaseClaim('${streamId}')" title="Release this claim">
                            <i class="material-icons align-middle" style="font-size: 14px;">close</i>
                        </button>
                    </td>
                </tr>`;
            }).join('');

        } catch (e) {
            console.error('Failed to load my claims:', e);
            tbody.innerHTML = '<tr><td colspan="6" class="text-center text-danger py-3">Failed to load claims</td></tr>';
        }
    }

    async function renewAllClaims() {
        try {
            showToast('Renewing all claims...');

            const result = await apiCall('/p2p/streams/renew-claims', 'POST');

            if (result && result.success) {
                showToast(`Renewed ${result.renewed} claims. ${result.failed > 0 ? `(${result.failed} failed)` : ''}`);
                loadMyClaims();  // Refresh the table
            } else {
                showToast('Failed to renew claims: ' + (result?.error || 'Unknown error'), true);
            }
        } catch (e) {
            console.error('Failed to renew claims:', e);
            showToast('Failed to renew claims: ' + e.message, true);
        }
    }

    async function releaseClaim(streamId) {
        if (!confirm(`Release claim on ${streamId}? This will stop predictions for this stream.`)) {
            return;
        }

        try {
            const result = await apiCall('/p2p/streams/release', 'POST', { stream_id: streamId });

            if (result && result.success) {
                showToast(`Released claim on ${streamId}`);
                loadMyClaims();  // Refresh the table
                loadPredictionStats();  // Update prediction stats
            } else {
                showToast('Failed to release claim: ' + (result?.error || 'Unknown error'), true);
            }
        } catch (e) {
            console.error('Failed to release claim:', e);
            showToast('Failed to release claim: ' + e.message, true);
        }
    }

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
        // Set up wallet import file input handler for modal
        const walletFolderInputModal = document.getElementById('walletFolderInputModal');
        if (walletFolderInputModal) {
            walletFolderInputModal.addEventListener('change', handleWalletFolderSelectModal);
        }

        // Update theme icon based on stored theme
        const storedTheme = localStorage.getItem('satori-theme') || 'dark';
        const themeIcon = document.getElementById('themeIcon');
        if (themeIcon) {
            themeIcon.textContent = storedTheme === 'dark' ? 'light_mode' : 'dark_mode';
        }

        // Initialize Bootstrap tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });

        // Ensure both pool cards start collapsed (will be expanded by API calls if needed)
        const poolStakingCollapse = document.getElementById('poolStakingCollapse');
        const poolManagementCollapse = document.getElementById('poolManagementCollapse');
        if (poolStakingCollapse) {
            poolStakingCollapse.classList.remove('show');
        }
        if (poolManagementCollapse) {
            poolManagementCollapse.classList.remove('show');
        }

        // Health check disabled to reduce API load
        // checkHealth();
        loadWalletAddresses();
        loadAllBalances();  // Load both stake and live balances from ElectrumX
        loadRewardAddress();
        loadStakingStatus();
        loadWorkers();
        loadLenders();
        loadAvailablePools();
        loadPoolCommission();
        loadAllP2PData();  // Load P2P network health, heartbeats, delegations
        loadTrainingDelay();  // Load AI engine training frequency setting
        loadDonationStats();  // Load donation stats and treasury address
        loadReferralStats();  // Load referral stats
        loadTreasuryAlerts();  // Load treasury alerts and deferred rewards
        loadMyRewardsHistory();  // Load personal rewards history
        loadPredictionStats();  // Load prediction stats
        loadPerformance();  // Load AI engine performance charts (upstream feature)
        loadMyClaims();  // Load my claimed streams

        // Periodic refresh of P2P data (every 30s)
        setInterval(loadP2PHealth, 30000);
        setInterval(loadHeartbeats, 15000);
        setInterval(loadPredictionStats, 60000);  // Refresh prediction stats every minute
        setInterval(loadTreasuryAlerts, 60000);  // Refresh alerts every minute
        setInterval(loadMyRewardsHistory, 120000);  // Refresh rewards every 2 minutes

        // Check if onboarding modal should be shown (after 2 second delay for P2P to initialize)
        setTimeout(checkAndShowOnboarding, 2000);
    });
</script>
{% endblock %}
